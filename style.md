<!--
  This file was generated by stitchmd. DO NOT EDIT.
  To make changes, edit the files in the "src" directory.
-->

<!-- markdownlint-disable MD033 -->

# Руководство по стилю Uber Go

- [Введение](#%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5)
- [Рекомендации](#рекомендации)
  - [Указатели на интерфейсы](#%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B8-%D0%BD%D0%B0-%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D1%8B)
  - [Проверка соответствия интерфейса](#%D0%BF%D1%80%D0%BE%D0%B2%D0%B5%D1%80%D0%BA%D0%B0-%D1%81%D0%BE%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%81%D1%82%D0%B2%D0%B8%D1%8F-%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D0%B0)
  - [Приемники и интерфейсы](#%D0%BF%D1%80%D0%B8%D0%B5%D0%BC%D0%BD%D0%B8%D0%BA%D0%B8-%D0%B8-%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D1%8B)
  - [Допустимы мьютексы с нулевым значением](#%D0%B4%D0%BE%D0%BF%D1%83%D1%81%D1%82%D0%B8%D0%BC%D1%8B-%D0%BC%D1%8C%D1%8E%D1%82%D0%B5%D0%BA%D1%81%D1%8B-%D1%81-%D0%BD%D1%83%D0%BB%D0%B5%D0%B2%D1%8B%D0%BC-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC)
  - [Копировать фрагменты и карты по границам](#%D1%81%D0%BA%D0%BE%D0%BF%D0%B8%D1%80%D1%83%D0%B9%D1%82%D0%B5-%D1%81%D1%80%D0%B5%D0%B7%D1%8B-%D0%B8-%D0%BA%D0%B0%D1%80%D1%82%D1%8B-%D0%BD%D0%B0-%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D0%B0%D1%85)
  - [Отложить очистку](#%D0%BE%D1%82%D0%BB%D0%BE%D0%B6%D0%B8%D1%82%D1%8C-%D0%BE%D1%87%D0%B8%D1%81%D1%82%D0%BA%D1%83)
  - [Размер канала равен единице или отсутствует](#%D1%80%D0%B0%D0%B7%D0%BC%D0%B5%D1%80-%D0%BA%D0%B0%D0%BD%D0%B0%D0%BB%D0%B0-%D1%80%D0%B0%D0%B2%D0%B5%D0%BD-%D0%B5%D0%B4%D0%B8%D0%BD%D0%B8%D1%86%D0%B5-%D0%B8%D0%BB%D0%B8-%D0%BD%D0%B5-%D0%B8%D0%BC%D0%B5%D0%B5%D1%82-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F)
  - [Начинать перечисление с единицы](#%D0%BD%D0%B0%D1%87%D0%B8%D0%BD%D0%B0%D0%B9%D1%82%D0%B5-%D0%BF%D0%B5%D1%80%D0%B5%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-%D1%81-%D0%B5%D0%B4%D0%B8%D0%BD%D0%B8%D1%86%D1%8B)
  - [Используйте `time" для обработки времени](#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-time-%D0%B4%D0%BB%D1%8F-%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%B5%D0%BC)
  - [Ошибки](#ошибки)
    - [Типы ошибок](#%D1%82%D0%B8%D0%BF%D1%8B-%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA)
    - [Перенос ошибок](#%D0%BF%D0%B5%D1%80%D0%B5%D0%BD%D0%BE%D1%81-%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA)
    - [Присвоение имени ошибке](#%D0%BF%D1%80%D0%B8%D1%81%D0%B2%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B8%D0%BC%D0%B5%D0%BD-%D0%BE%D1%88%D0%B8%D0%B1%D0%BA%D0%B0%D0%BC)
    - [Однократная обработка ошибок](#%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%B0%D1%82%D1%8B%D0%B2%D0%B0%D1%82%D1%8C-%D0%BE%D1%88%D0%B8%D0%B1%D0%BA%D0%B8-%D0%BE%D0%B4%D0%B8%D0%BD-%D1%80%D0%B0%D0%B7)
  - [Обработка ошибок при подтверждении типа](#%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D1%82%D1%8C-%D0%BE%D1%88%D0%B8%D0%B1%D0%BA%D0%B8-%D0%BF%D1%80%D0%B8-%D0%BF%D0%BE%D0%B4%D1%82%D0%B2%D0%B5%D1%80%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B8-%D1%82%D0%B8%D0%BF%D0%B0)
  - [Не паникуйте](#%D0%BD%D0%B5-%D0%BF%D0%B0%D0%BD%D0%B8%D0%BA%D1%83%D0%B9%D1%82%D0%B5)
  - [Используйте go.uber.org/atomic](#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9-gouberorgatomic)
  - [Избегайте изменяемых глобальных параметров](#%D0%B8%D0%B7%D0%B1%D0%B5%D0%B3%D0%B0%D0%B9%D1%82%D0%B5-%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D1%8F%D0%B5%D0%BC%D1%8B%D1%85-%D0%B3%D0%BB%D0%BE%D0%B1%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D1%85-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85)
  - [Избегайте встраивания типов в общедоступные структуры](#%D0%B8%D0%B7%D0%B1%D0%B5%D0%B3%D0%B0%D0%B9%D1%82%D0%B5-%D0%B2%D1%81%D1%82%D1%80%D0%B0%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2-%D0%B2-%D0%BE%D0%B1%D1%89%D0%B5%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%BD%D1%8B%D0%B5-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B)
  - [Избегайте использования встроенных имен](#%D0%B8%D0%B7%D0%B1%D0%B5%D0%B3%D0%B0%D0%B9%D1%82%D0%B5-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%BD%D1%8B%D1%85-%D0%B8%D0%BC%D0%B5%D0%BD)
  - [Избегайте `init()`](#%D0%B8%D0%B7%D0%B1%D0%B5%D0%B3%D0%B0%D0%B9%D1%82%D0%B5-init)
  - [Выход в главном меню](#%D0%B7%D0%B0%D0%B2%D0%B5%D1%80%D1%88%D0%B8%D1%82%D0%B5-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%83-%D0%B2-%D0%B3%D0%BB%D0%B0%D0%B2%D0%BD%D0%BE%D0%BC-%D0%BC%D0%B5%D0%BD%D1%8E)
    - [Выход один раз](#%D0%B7%D0%B0%D0%B2%D0%B5%D1%80%D1%88%D0%B8%D1%82%D0%B5-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%83-%D0%BE%D0%B4%D0%B8%D0%BD-%D1%80%D0%B0%D0%B7)
  - [Использовать теги полей в упорядоченных структурах](#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-%D1%82%D0%B5%D0%B3%D0%B8-%D0%BF%D0%BE%D0%BB%D0%B5%D0%B9-%D0%B2-%D1%83%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D1%87%D0%B5%D0%BD%D0%BD%D1%8B%D1%85-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0%D1%85)
  - [Не запускайте и не забывайте о подпрограммах](#%D0%BD%D0%B5-%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D0%BA%D0%B0%D0%B9%D1%82%D0%B5-%D0%B8-%D0%BD%D0%B5-%D0%B7%D0%B0%D0%B1%D1%8B%D0%B2%D0%B0%D0%B9%D1%82%D0%B5-%D0%BE-%D0%BF%D0%BE%D0%B4%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0%D1%85)
    - [Дождитесь завершения подпрограмм](#%D0%B4%D0%BE%D0%B6%D0%B4%D0%B8%D1%82%D0%B5%D1%81%D1%8C-%D0%B7%D0%B0%D0%B2%D0%B5%D1%80%D1%88%D0%B5%D0%BD%D0%B8%D1%8F-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B-%D0%BF%D0%BE%D0%B4%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D1%8B)
    - [В `init()` нет подпрограмм](#%D0%BD%D0%B8%D0%BA%D0%B0%D0%BA%D0%B8%D1%85-%D0%BF%D0%BE%D0%B4%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC-%D0%B2-init)
- [Производительность](#%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%BE%D0%B4%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C)
  - [Предпочитайте strconv, а не fmt](#%D0%BF%D1%80%D0%B5%D0%B4%D0%BF%D0%BE%D1%87%D0%B8%D1%82%D0%B0%D0%B9%D1%82%D0%B5-strconv-%D0%B0-%D0%BD%D0%B5-fmt)
  - [Избегайте повторных преобразований строк в байты](#%D0%B8%D0%B7%D0%B1%D0%B5%D0%B3%D0%B0%D0%B9%D1%82%D0%B5-%D0%BF%D0%BE%D0%B2%D1%82%D0%BE%D1%80%D0%BD%D1%8B%D1%85-%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B9-%D1%81%D1%82%D1%80%D0%BE%D0%BA-%D0%B2-%D0%B1%D0%B0%D0%B9%D1%82%D1%8B)
  - [Предпочитайте указывать емкость контейнера](#%D0%BF%D1%80%D0%B5%D0%B4%D0%BF%D0%BE%D1%87%D1%82%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%B5%D0%B5-%D1%83%D0%BA%D0%B0%D0%B7%D1%8B%D0%B2%D0%B0%D1%82%D1%8C-%D0%B5%D0%BC%D0%BA%D0%BE%D1%81%D1%82%D1%8C-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D0%B0)
- [Стиль](#стиль)
  - [Избегайте слишком длинных строк](#%D0%B8%D0%B7%D0%B1%D0%B5%D0%B3%D0%B0%D0%B9%D1%82%D0%B5-%D1%81%D0%BB%D0%B8%D1%88%D0%BA%D0%BE%D0%BC-%D0%B4%D0%BB%D0%B8%D0%BD%D0%BD%D1%8B%D1%85-%D1%81%D1%82%D1%80%D0%BE%D0%BA)
  - [Соблюдать последовательность](#%D0%B1%D1%83%D0%B4%D1%8C%D1%82%D0%B5-%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B)
  - [Группировать похожие объявления](#%D0%B3%D1%80%D1%83%D0%BF%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-%D0%BF%D0%BE%D1%85%D0%BE%D0%B6%D0%B8%D0%B5-%D0%BE%D0%B1%D1%8A%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F)
  - [Групповой порядок импорта](#%D1%83%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B3%D1%80%D1%83%D0%BF%D0%BF-%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82%D0%B0)
  - [Названия пакетов](#%D0%B8%D0%BC%D0%B5%D0%BD%D0%B0-%D0%BF%D0%B0%D0%BA%D0%B5%D1%82%D0%BE%D0%B2)
  - [Имена функций](#%D0%B8%D0%BC%D0%B5%D0%BD%D0%B0-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9)
  - [Сглаживание при импорте](#%D1%81%D0%B3%D0%BB%D0%B0%D0%B6%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%B8-%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82%D0%B5)
  - [Группировка и упорядочение функций](#%D0%B3%D1%80%D1%83%D0%BF%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0-%D0%B8-%D1%83%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9)
  - [Уменьшение вложенности](#%D1%83%D0%BC%D0%B5%D0%BD%D1%8C%D1%88%D0%B8%D1%82%D1%8C-%D0%B2%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D1%8C)
  - [Ненужное другое](#%D0%BD%D0%B5%D0%BE%D0%B1%D1%8F%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82-else)
  - [Объявления переменных верхнего уровня](#%D0%BE%D0%B1%D1%8A%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85-%D0%B2%D0%B5%D1%80%D1%85%D0%BD%D0%B5%D0%B3%D0%BE-%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D1%8F)
  - [Добавляйте к неэкспортируемым глобальным значениям префикс _](#%D0%B4%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D1%8F%D0%B9%D1%82%D0%B5-%D0%BA-%D0%BD%D0%B5%D1%8D%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82%D0%B8%D1%80%D1%83%D0%B5%D0%BC%D1%8B%D0%BC-%D0%B3%D0%BB%D0%BE%D0%B1%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%BC-%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D0%B0%D0%BC-%D0%BF%D1%80%D0%B5%D1%84%D0%B8%D0%BA%D1%81-_)
  - [Встраивание в структуры](#-%D0%B2%D1%81%D1%82%D1%80%D0%B0%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B2-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B)
  - [Объявления локальных переменных](#%D0%BE%D0%B1%D1%8A%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D1%85-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85)
  - [допустимый фрагмент равен нулю](#nil---%D0%B4%D0%BE%D0%BF%D1%83%D1%81%D1%82%D0%B8%D0%BC%D1%8B%D0%B9-%D1%84%D1%80%D0%B0%D0%B3%D0%BC%D0%B5%D0%BD%D1%82)
  - [Сокращение области видимости переменных](#%D1%83%D0%BC%D0%B5%D0%BD%D1%8C%D1%88%D0%B8%D1%82%D0%B5-%D0%BE%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C-%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85)
  - [Избегайте открытых параметров](#%D0%B8%D0%B7%D0%B1%D0%B5%D0%B3%D0%B0%D0%B9%D1%82%D0%B5-%D0%BE%D1%82%D0%BA%D1%80%D1%8B%D1%82%D1%8B%D1%85-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%BE%D0%B2)
  - [Используйте необработанные строковые литералы, чтобы избежать экранирования](#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-%D0%BD%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BB%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D0%BB%D1%8B-%D1%87%D1%82%D0%BE%D0%B1%D1%8B-%D0%B8%D0%B7%D0%B1%D0%B5%D0%B6%D0%B0%D1%82%D1%8C-%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
  - [Инициализация структур](#инициализация-структур)
    - [Используйте имена полей для инициализации структур](#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-%D0%B8%D0%BC%D0%B5%D0%BD%D0%B0-%D0%BF%D0%BE%D0%BB%D0%B5%D0%B9-%D0%B4%D0%BB%D1%8F-%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80)
    - [Опустите поля с нулевыми значениями в структурах](#%D0%BE%D0%BF%D1%83%D1%81%D1%82%D0%B8%D1%82%D0%B5-%D0%BF%D0%BE%D0%BB%D1%8F-%D1%81-%D0%BD%D1%83%D0%BB%D0%B5%D0%B2%D1%8B%D0%BC%D0%B8-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F%D0%BC%D0%B8-%D0%B2-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0%D1%85)
    - [Использовать `var` для структур с нулевым значением](#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-var-%D0%B4%D0%BB%D1%8F-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80-%D1%81-%D0%BD%D1%83%D0%BB%D0%B5%D0%B2%D1%8B%D0%BC-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC)
    - [Инициализация ссылок на структуры](#%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D1%81%D1%81%D1%8B%D0%BB%D0%BE%D0%BA-%D0%BD%D0%B0-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B)
  - [Инициализация карт](#%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BA%D0%B0%D1%80%D1%82)
  - [Форматирование строк вне Printf](#%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8-%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2%D0%BD%D0%B5-printf)
  - [Присвоение имен функциям в стиле Printf](#%D0%BF%D1%80%D0%B8%D1%81%D0%B2%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B8%D0%BC%D0%B5%D0%BD-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F%D0%BC-%D0%B2-%D1%81%D1%82%D0%B8%D0%BB%D0%B5-printf)
- [Шаблоны](#шаблоны)
  - [Тестовые таблицы](#%D1%82%D0%B5%D1%81%D1%82%D0%BE%D0%B2%D1%8B%D0%B5-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8B)
  - [Функциональные опции](#%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D1%8B)
- [Подкладка](#linting)

## Введение

Стили - это соглашения, которые управляют нашим кодом. Термин "стиль" несколько
неуместен, поскольку эти соглашения охватывают гораздо больше, чем просто
форматирование исходного файла — gofmt обрабатывает это за нас.

Цель данного руководства - справиться с этой сложностью, подробно описав
Что можно и чего нельзя делать при написании кода Go в Uber. Эти правила существуют для того, чтобы обеспечить
управляемость кодовой базой и в то же время позволить инженерам продуктивно использовать возможности языка Go
.

Это руководство было первоначально создано [Прашантом Варанаси] и [Саймоном Ньютоном] в качестве
это способ познакомить некоторых коллег с использованием Go. За прошедшие годы в него
были внесены изменения, основанные на отзывах других пользователей.

Это документирует идиоматические соглашения в коде Go, которым мы следуем в Uber. Многие
из них являются общими рекомендациями для Go, в то время как другие распространяются на внешние
ресурсы:

1. [Эффективный Go](https://go.dev/doc/effective_go)
2. [Распространенные ошибки Go](https://go.dev/wiki/CommonMistakes)
3. [Комментарии к обзору кода Go](https://go.dev/wiki/CodeReviewComments)

Мы стремимся к тому, чтобы примеры кода были точными для двух последних версий
Go (https://go.dev/doc/devel/release).

Весь код должен быть безошибочным при запуске через `golint` и `go vet`. Мы
рекомендуем настроить ваш редактор таким образом, чтобы:

- Запустите `goimports` при сохранении
- Запустите `golint` и `go vet`, чтобы проверить наличие ошибок

Вы можете найти информацию о поддержке редактора инструментов Go здесь:
https://go.dev/wiki/IDEsAndTextEditorPlugins

## Рекомендации

### Указатели на интерфейсы

Указатель на интерфейс практически никогда не требуется. Вы должны передавать
интерфейсы в виде значений — базовые данные все равно могут быть указателями.

Интерфейс - это два поля:

1. Указатель на некоторую информацию, относящуюся к определенному типу. Вы можете представить это как
   "тип".
2. Указатель на данные. Если сохраненные данные являются указателем, они сохраняются непосредственно. Если
   сохраненные данные являются значением, то сохраняется указатель на значение.

Если вы хотите, чтобы интерфейсные методы изменяли базовые данные, вы должны использовать
указатель.

### Проверка соответствия интерфейса

При необходимости проверьте соответствие интерфейса во время компиляции. Это включает в себя:

- Экспортированные типы, которые требуются для реализации определенных интерфейсов в рамках
  их контракта API
- Экспортированные или неэкспортированные типы, которые являются частью коллекции типов
  реализующих один и тот же интерфейс
- Другие случаи, когда нарушение интерфейса может привести к нарушению работы пользователей

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
type Handler struct {
  // ...
}



func (h *Handler) ServeHTTP(
  w http.ResponseWriter,
  r *http.Request,
) {
  ...
}
```

</td><td>

```go
type Handler struct {
  // ...
}

var _ http.Handler = (*Handler)(nil)

func (h *Handler) ServeHTTP(
  w http.ResponseWriter,
  r *http.Request,
) {
  // ...
}
```

</td></tr>
</tbody></table>

Оператор `var _ http.Handler = (*Handler)(nil)` не удастся скомпилировать, если
`*Handler` когда-либо перестанет соответствовать интерфейсу `http.Handler`.

В правой части присваивания должно быть нулевое значение указанного
типа. Это значение равно "nil" для типов указателей (например, "*Handler"), срезов и отображений, а
также пустой struct для структурных типов.

```go
type LogHandler struct {
  h   http.Handler
  log *zap.Logger
}

var _ http.Handler = LogHandler{}

func (h LogHandler) ServeHTTP(
  w http.ResponseWriter,
  r *http.Request,
) {
  // ...
}
```

### Приемники и интерфейсы

Методы с приемниками значений могут вызываться как для указателей, так и для значений.
Методы с приемниками указателей могут вызываться только для указателей или [адресуемых значений].

Например,

```go
type S struct {
  data string
}

func (s S) Read() string {
  return s.data
}

func (s *S) Write(str string) {
  s.data = str
}

// Мы не можем получить указатели на значения, хранящиеся в картах, потому что они не являются
// адресуемыми значениями.
sVals := map[int]S{1: {"A"}}

// Мы можем вызвать Read для значений, хранящихся в map, потому что Read
// имеет приемник значений, который не требует, чтобы значение
// было адресуемым.
sVals[1].Read()

// Мы не можем вызвать функцию Write для значений, хранящихся на карте, потому что функция Write
// имеет приемник указателей, а получить указатель
// на значение, хранящееся на карте, невозможно.
//
// sVals[1].Write("test")

sPtrs := map[int]*S{1: {"A"}}

// Вы можете вызывать как Read, так и Write, если карта хранит указатели,
// потому что указатели по своей сути адресуемы.
sPtrs[1].Read()
sPtrs[1].Write("test")
```

Аналогично, интерфейс может быть удовлетворен указателем, даже если у метода есть
получатель значений.

```go
type F interface {
  f()
}

type S1 struct{}

func (s S1) f() {}

type S2 struct{}

func (s *S2) f() {}

s1Val := S1{}
s1Ptr := &S1{}
s2Val := S2{}
s2Ptr := &S2{}

var i F
i = s1Val
i = s1Ptr
i = s2Ptr

// // Следующее не скомпилируется, поскольку s2Val - это значение, а для f нет приемника значений.
// i = s2Val
```

В Effective Go есть хорошая статья о [указатели и  значения](https://go.dev/doc/effective_go#pointers_vs_values).

### Допустимы мьютексы с нулевым значением

Допустимо нулевое значение `sync.Mutex` и `sync.RWMutex`, поэтому вам почти
никогда не понадобится указатель на мьютекс.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
mu := new(sync.Mutex)
mu.Lock()
```

</td><td>

```go
var mu sync.Mutex
mu.Lock()
```

</td></tr>
</tbody></table>

Если вы используете структуру по указателю, то мьютекс должен быть полем без указателя на
него. Не вставляйте мьютекс в структуру, даже если структура не экспортируется.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
type SMap struct {
  sync.Mutex

  data map[string]string
}

func NewSMap() *SMap {
  return &SMap{
    data: make(map[string]string),
  }
}

func (m *SMap) Get(k string) string {
  m.Lock()
  defer m.Unlock()

  return m.data[k]
}
```

</td><td>

```go
type SMap struct {
  mu sync.Mutex

  data map[string]string
}

func NewSMap() *SMap {
  return &SMap{
    data: make(map[string]string),
  }
}

func (m *SMap) Get(k string) string {
  m.mu.Lock()
  defer m.mu.Unlock()

  return m.data[k]
}
```

</td></tr>

<tr><td>

Поле `Mutex`, а также методы "Lock" и "Unlock" непреднамеренно являются частью
экспортируемого API `SMap`.

</td><td>

Мьютекс и его методы - это детали реализации SMap, скрытые от
вызывающих его объектов.

</td></tr>
</tbody></table>

### Скопируйте срезы и карты на границах

Срезы и карты содержат указатели на базовые данные, поэтому будьте осторожны со сценариями
, когда их необходимо скопировать.

#### Получение срезов и карт

Имейте в виду, что пользователи могут изменять карту или срез, полученные вами в качестве аргумента
, если вы сохраните ссылку на них.

<table>
<thead><tr><th>Bad</th> <th>Good</th></tr></thead>
<tbody>
<tr>
<td>

```go
func (d *Driver) SetTrips(trips []Trip) {
  d.trips = trips
}

trips := ...
d1.SetTrips(trips)

// Did you mean to modify d1.trips?
trips[0] = ...
```

</td>
<td>

```go
func (d *Driver) SetTrips(trips []Trip) {
  d.trips = make([]Trip, len(trips))
  copy(d.trips, trips)
}

trips := ...
d1.SetTrips(trips)

// Теперь мы можем изменять trips[0], не затрагивая d1.trips.
trips[0] = ...
```

</td>
</tr>

</tbody>
</table>

#### Возвращаем фрагменты и карты

Аналогичным образом, будьте осторожны с пользовательскими изменениями карт или фрагментов, раскрывающими внутреннее
состояние.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
type Stats struct {
  mu sync.Mutex
  counters map[string]int
}

// // Snapshot возвращает текущую статистику.
func (s *Stats) Snapshot() map[string]int {
  s.mu.Lock()
  defer s.mu.Unlock()

  return s.counters
}

// моментальный снимок больше не защищен мьютексом, поэтому любой
// доступ к моментальному снимку зависит от скачков данных.
snapshot := stats.Snapshot()
```

</td><td>

```go
type Stats struct {
  mu sync.Mutex
  counters map[string]int
}

func (s *Stats) Snapshot() map[string]int {
  s.mu.Lock()
  defer s.mu.Unlock()

  result := make(map[string]int, len(s.counters))
  for k, v := range s.counters {
    result[k] = v
  }
  return result
}

// Snapshot is теперь является копией.
snapshot := stats.Snapshot()
```

</td></tr>
</tbody></table>

### Отложить очистку

Используйте функцию отложить для очистки ресурсов, таких как файлы и блокировки.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
p.Lock()
if p.count < 10 {
  p.Unlock()
  return p.count
}

p.count++
newCount := p.count
p.Unlock()

return newCount

// легко пропускаемые разблокировки из-за многократных возвратов
```

</td><td>

```go
p.Lock()
defer p.Unlock()

if p.count < 10 {
  return p.count
}

p.count++
return p.count

// более читабельный
```

</td></tr>
</tbody></table>

При использовании Defer накладные расходы чрезвычайно малы, и их следует избегать, только если вы можете
доказать, что время выполнения вашей функции составляет порядка наносекунд. Преимущество
использования defer в удобочитаемости оправдывает минимальные затраты на их использование. Это
особенно верно для более крупных методов, которые имеют нечто большее, чем простой
доступ к памяти, где другие вычисления более важны, чем "отсрочка`.

### Размер канала равен единице или не имеет значения

Каналы обычно должны иметь размер, равный единице, или быть небуферизованными. По умолчанию
каналы не имеют буферизации и имеют нулевой размер. Любой другой размер
должен быть предметом тщательной проверки. Рассмотрим, как
определяется размер, что препятствует заполнению канала под нагрузкой и блокированию
записи, и что происходит, когда это происходит.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
// Этого должно быть достаточно для любого!
c := make(chan int, 64)
```

</td><td>

```go
// размера 1
c := make(chan int, 1) // или
// Небуферизованный канал, размер которого равен нулю
c := make(chan int)
```

</td></tr>
</tbody></table>

### Начинайте перечисления с единицы

Стандартный способ введения перечислений в Go - это объявить пользовательский тип
и группу `const` с помощью `iota`. Поскольку переменные по умолчанию имеют значение 0,
обычно вы должны начинать перечисления с ненулевого значения.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
type Operation int

const (
  Add Operation = iota
  Subtract
  Multiply
)

// Add=0, Subtract=1, Multiply=2
```

</td><td>

```go
type Operation int

const (
  Add Operation = iota + 1
  Subtract
  Multiply
)

// Add=1, Subtract=2, Multiply=3
```

</td></tr>
</tbody></table>

Есть случаи, когда использование нулевого значения имеет смысл, например, когда
нулевое значение является желательным поведением по умолчанию.

```go
type LogOutput int

const (
  LogToStdout LogOutput = iota
  LogToFile
  LogToRemote
)

// LogToStdout=0, LogToFile=1, LogToRemote=2
```

<!-- TODO: section on String methods for enums -->

### Используйте `time` для управления временем

Время - это сложная штука. Часто делаются следующие неверные предположения о времени
.

1. В сутках 24 часа
2. В часе 60 минут
3. В неделе 7 дней
4. В году 365 дней
5. [И многое другое](https://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time)

Например, *1* означает, что добавление 24 часов к моменту времени не всегда
приводит к появлению нового календарного дня.

Поэтому всегда используйте пакет [`"time"`](https://pkg.go.dev/time) при работе со временем, поскольку он
помогает справиться с этими неверными предположениями более безопасным и точным способом.

#### Используйте `time.Time` для значений моментов времени

Используйте [`time.Time`](https://pkg.go.dev/time#Time) при работе с моментами времени и методы
"time.Время" при сравнении, сложении или вычитании времени.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
func isActive(now, start, stop int) bool {
  return start <= now && now < stop
}
```

</td><td>

```go
func isActive(now, start, stop time.Time) bool {
  return (start.Before(now) || start.Equal(now)) && now.Before(stop)
}
```

</td></tr>
</tbody></table>

#### Используйте `time.Продолжительность` для обозначения периодов времени

Используйте [`time.Длительность"], когда речь идет о периодах времени.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
func poll(delay int) {
  for {
    // ...
    time.Sleep(time.Duration(delay) * time.Millisecond)
  }
}

poll(10) // это были секунды или миллисекунды?
```

</td><td>

```go
func poll(delay time.Duration) {
  for {
    // ...
    time.Sleep(delay)
  }
}

poll(10*time.Second)
```

</td></tr>
</tbody></table>

Возвращаясь к примеру добавления 24 часов к моменту времени, метод, который мы
используем для добавления времени, зависит от цели. Если мы хотим получить то же время суток, но на
следующий календарный день, мы должны использовать [`Time.AddDate`](https://pkg.go.dev/time#Time.AddDate). Однако, если мы хотим
, чтобы момент времени гарантированно был на 24 часа позже предыдущего, мы должны
использовать [`Time.Add`](https://pkg.go.dev/time#Time.Add).

```go
newDay := t.AddDate(0 /* years */, 0 /* months */, 1 /* days */)
maybeNewDay := t.Add(24 * time.Hour)
```

#### Используйте `time.Time` и `time.Duration` во внешних системах

По возможности используйте `time.Duration` и `time.Time` при взаимодействии с внешними системами
. Например:

- Флаги командной строки: [`flag`](https://pkg.go.dev/flag) поддерживает "time".Длительность" с помощью
  [`time.ParseDuration`](https://pkg.go.dev/time#ParseDuration)
- JSON: [`encoding/json`](https://pkg.go.dev/encoding/json) поддерживает кодировку `time.Time` в виде строки [RFC 3339](https://tools.ietf.org/html/rfc3339)
  с помощью метода [`UnmarshalJSON`]
- SQL: [`database/sql`](https://pkg.go.dev/database/sql) поддерживает преобразование столбцов `DATETIME` или `TIMESTAMP`
  в `time.Time` и обратно, если базовый драйвер поддерживает это
- YAML: [`gopkg.in/yaml.v2`](https://pkg.go.dev/gopkg.in/yaml.v2) поддерживает `time.Time` в виде строки [RFC 3339](https://tools.ietf.org/html/rfc3339), и
  `time.Duration` через [`time.ParseDuration`](https://pkg.go.dev/time#ParseDuration).

Если использовать `time.Duration` невозможно в этих взаимодействиях, используйте
`int` или `float64` и укажите единицу измерения в названии поля.

Например, поскольку `encoding/json` не поддерживает `time.Duration`, единица
измерения включена в название поля.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
// {"interval": 2}
type Config struct {
  Interval int `json:"interval"`
}
```

</td><td>

```go
// {"intervalMillis": 2000}
type Config struct {
  IntervalMillis int `json:"intervalMillis"`
}
```

</td></tr>
</tbody></table>

Когда использовать `time.Time` невозможно.При таких взаимодействиях, если
не согласован альтернативный вариант, используйте "string" и форматируйте временные метки, как определено в
[RFC 3339](https://tools.ietf.org/html/rfc3339). Этот формат по умолчанию используется [`Time.UnmarshalText`](https://pkg.go.dev/time#Time.UnmarshalText) и
доступен для использования в `Time.Format` и `time.Parse` с помощью [`time.RFC3339`](https://pkg.go.dev/time#RFC3339).

Хотя на практике это, как правило, не является проблемой, имейте в виду, что
пакет `"time"` не поддерживает синтаксический анализ временных меток с использованием високосных секунд
([8728](https://github.com/golang/go/issues/8728)), а также не учитывает високосные секунды в расчетах ([15190](https://github.com/golang/go/issues/15190)). Если
вы сравниваете два момента времени, разница не будет включать в себя високосные
секунды, которые могли произойти между этими двумя моментами.

### Ошибки

#### Типы ошибок

Существует несколько вариантов объявления ошибок.
Прежде чем выбрать вариант, наиболее подходящий для вашего варианта использования, рассмотрите следующее.

- Должен ли вызывающий объект сопоставлять ошибку, чтобы он мог ее обработать?
  Если да, мы должны поддерживать ошибки [`.Is`] или [`ошибки.Как`] функции
  путем объявления переменной ошибки верхнего уровня или пользовательского типа.
- Является ли сообщение об ошибке статической строкой
  или динамической строкой, требующей контекстной информации?
  Для первого мы можем использовать [`errors.New`](https://pkg.go.dev/errors#New), но для второго мы должны
  использовать [`fmt.Errorf`](https://pkg.go.dev/fmt#Errorf) или пользовательский тип ошибки.
- Распространяем ли мы новую ошибку, возвращаемую нисходящей функцией?
  Если да, то смотрите [раздел, посвященный переносу ошибок](#%D0%BF%D0%B5%D1%80%D0%B5%D0%BD%D0%BE%D1%81-%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA).

| Error matching? | Error Message | Guidance                                                           |
|-----------------|---------------|--------------------------------------------------------------------|
| No              | static        | [`errors.New`](https://pkg.go.dev/errors#New)                      |
| No              | dynamic       | [`fmt.Errorf`](https://pkg.go.dev/fmt#Errorf)                      |
| Yes             | static        | top-level `var` with [`errors.New`](https://pkg.go.dev/errors#New) |
| Yes             | dynamic       | пользовательский тип `error`                                       |

Например,
используйте [`errors.New`](https://pkg.go.dev/errors#New) для ошибки со статической строкой.
Экспортируйте эту ошибку в качестве переменной, чтобы поддерживать сопоставление с `errors.Is",
если вызывающей стороне необходимо сопоставить и обработать эту ошибку.

<table>
<thead><tr><th>No error matching</th><th>Error matching</th></tr></thead>
<tbody>
<tr><td>

```go
// package foo

func Open() error {
  return errors.New("could not open")
}

// package bar

if err := foo.Open(); err != nil {
  // Can't handle the error.
  panic("unknown error")
}
```

</td><td>

```go
// package foo

var ErrCouldNotOpen = errors.New("could not open")

func Open() error {
  return ErrCouldNotOpen
}

// package bar

if err := foo.Open(); err != nil {
  if errors.Is(err, foo.ErrCouldNotOpen) {
    // handle the error
  } else {
    panic("unknown error")
  }
}
```

</td></tr>
</tbody></table>

Для ошибки с динамической строкой
используйте [`fmt.Errorf`](https://pkg.go.dev/fmt#Errorf), если вызывающей стороне не нужно сопоставлять ее,
и пользовательскую "ошибку", если вызывающей стороне действительно нужно сопоставить ее.

<table>
<thead><tr><th>No error matching</th><th>Error matching</th></tr></thead>
<tbody>
<tr><td>

```go
// package foo

func Open(file string) error {
  return fmt.Errorf("file %q not found", file)
}

// package bar

if err := foo.Open("testfile.txt"); err != nil {
  // Can't handle the error.
  panic("unknown error")
}
```

</td><td>

```go
// package foo

type NotFoundError struct {
  File string
}

func (e *NotFoundError) Error() string {
  return fmt.Sprintf("file %q not found", e.File)
}

func Open(file string) error {
  return &NotFoundError{File: file}
}


// package bar

if err := foo.Open("testfile.txt"); err != nil {
  var notFound *NotFoundError
  if errors.As(err, &notFound) {
    // handle the error
  } else {
    panic("unknown error")
  }
}
```

</td></tr>
</tbody></table>

Обратите внимание, что если вы экспортируете переменные или типы ошибок из пакета,
они станут частью общедоступного API пакета.

#### Перенос ошибок

Существует три основных варианта распространения ошибок в случае сбоя вызова:

- вернуть исходную ошибку как есть
- добавить контекст с помощью `fmt.Errorf` и глагола `%w`
- добавьте контекст с помощью `fmt.Errorf` и глагола `%v`

Верните исходную ошибку как есть, если нет дополнительного контекста для добавления.
При этом сохраняются исходный тип ошибки и сообщение.
Это хорошо подходит для случаев, когда исходное сообщение об ошибке
содержит достаточно информации, чтобы отследить, откуда оно пришло.

В противном случае, по возможности, добавьте контекст к сообщению об ошибке
, чтобы вместо неопределенной ошибки, такой как "отказано в подключении", отображалась ошибка,
вы получаете более полезные ошибки, такие как "вызов службы foo: отказано в подключении".

Используйте `fmt.Errorf`, чтобы добавить контекст к вашим ошибкам,
выбирая между глаголами `%w` или `%v`
в зависимости от того, сможет ли вызывающий
объект сопоставить и извлечь основную причину.

- Используйте `%w`, если вызывающий абонент должен иметь доступ к основной ошибке.
  Это хорошее значение по умолчанию для большинства обернутых ошибок,
  но имейте в виду, что вызывающие абоненты могут начать полагаться на такое поведение.
  Таким образом, в случаях, когда обернутая ошибка является известным значением "var" или типом,
  задокументируйте и протестируйте ее как часть контракта вашей функции.
- Используйте `%v`, чтобы скрыть основную ошибку.
  Вызывающие абоненты не смогут найти ее,
  но вы можете переключиться на "%w" в будущем, если потребуется.

При добавлении контекста к возвращаемым ошибкам сохраняйте краткость контекста, избегая
таких фраз, как "не удалось выполнить", которые указывают на очевидное и накапливаются по мере распространения ошибки
по стеку:

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
s, err := store.New()
if err != nil {
    return fmt.Errorf(
        "failed to create new store: %w", err)
}
```

</td><td>

```go
s, err := store.New()
if err != nil {
    return fmt.Errorf(
        "new store: %w", err)
}
```

</td></tr><tr><td>

```plain
failed to x: failed to y: failed to create new store: the error
```

</td><td>

```plain
x: y: new store: the error
```

</td></tr>
</tbody></table>

Однако, как только ошибка отправляется в другую систему, должно быть ясно
, что сообщение является ошибкой (например, тег "err" или префикс "Failed" в журналах).

Смотрите также [Не просто проверяйте ошибки, а корректно обрабатывайте их](https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully).

#### Присвоение имен ошибкам

Для значений ошибок, сохраненных в виде глобальных переменных,
используйте префикс "Err" или "ошибка" в зависимости от того, были ли они экспортированы.
Это руководство заменяет [Префикс неэкспортированных глобальных переменных на _](#%D0%B4%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D1%8F%D0%B9%D1%82%D0%B5-%D0%BA-%D0%BD%D0%B5%D1%8D%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82%D0%B8%D1%80%D1%83%D0%B5%D0%BC%D1%8B%D0%BC-%D0%B3%D0%BB%D0%BE%D0%B1%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%BC-%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D0%B0%D0%BC-%D0%BF%D1%80%D0%B5%D1%84%D0%B8%D0%BA%D1%81-_).

```go
var (
  // Следующие две ошибки экспортированы,
  // чтобы пользователи этого пакета могли сопоставить их
  // с errors.Is.

  ErrBrokenLink = errors.New("link is broken")
  ErrCouldNotOpen = errors.New("could not open")

  // Эта ошибка не экспортируется, потому что
  // мы не хотим делать ее частью нашего общедоступного API.
  // Мы все еще можем использовать ее внутри пакета
  // с помощью errors.Is.

  errNotFound = errors.New("not found")
)
```

Для пользовательских типов ошибок используйте вместо них суффикс `Error`.

```go
// Аналогично, эта ошибка экспортируется,
//чтобы пользователи этого пакета могли сопоставить ее
// с errors.As.

type NotFoundError struct {
  File string
}

func (e *NotFoundError) Error() string {
  return fmt.Sprintf("file %q not found", e.File)
}

// И эта ошибка не экспортируется, потому что
// мы не хотим делать ее частью общедоступного API.
// Мы все еще можем использовать ее внутри пакета
// с помощью errors.As.

type resolveError struct {
  Path string
}

func (e *resolveError) Error() string {
  return fmt.Sprintf("resolve %q", e.Path)
}
```

#### Обрабатывать ошибки один раз

Когда вызывающий абонент получает сообщение об ошибке от вызываемого объекта,
он может обрабатывать его различными способами
в зависимости от того, что ему известно об ошибке.

К ним относятся, но не ограничиваются ими:

- если контракт вызываемого абонента определяет конкретные ошибки,
  сопоставьте ошибку с "errors.Is`или`errors.As"
  и обработайте ветви по-разному
- если ошибка исправима,
  зарегистрируйте ошибку и исправьте ее корректно
- если ошибка представляет собой сбой, связанный с конкретным доменом,
  возвращает четко определенную ошибку
- возвращает ошибку, либо [завернутую](#%D0%BF%D0%B5%D1%80%D0%B5%D0%BD%D0%BE%D1%81-%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA), либо дословно

Независимо от того, как вызывающий абонент обрабатывает ошибку,
обычно он должен обрабатывать каждую ошибку только один раз.
Вызывающий абонент не должен, например, регистрировать ошибку и затем возвращать ее,
поскольку *его* вызывающие абоненты также могут обрабатывать ошибку.

Например, рассмотрим следующие случаи:

<table>
<thead><tr><th>Description</th><th>Code</th></tr></thead>
<tbody>
<tr><td>

**Bad**: Зарегистрируйте ошибку и верните ее

Абоненты, находящиеся выше по стеку, скорее всего, предпримут аналогичные действия с ошибкой.
Это приведет к появлению большого количества помех в журналах приложений, что не принесет никакой пользы.

</td><td>

```go
u, err := getUser(id)
if err != nil {
  // BAD: See description
  log.Printf("Could not get user %q: %v", id, err)
  return err
}
```

</td></tr>
<tr><td>

**Good**: Обработайте ошибку и верните ее обратно

Вызывающие абоненты, расположенные выше по стеку, обработают ошибку.
Использование "%w" гарантирует, что они смогут сопоставить ошибку с `errors.Is` или `errors.As"
, если это уместно.

</td><td>

```go
u, err := getUser(id)
if err != nil {
  return fmt.Errorf("get user %q: %w", id, err)
}
```

</td></tr>
<tr><td>

**Good**: Зарегистрируйте ошибку и исправьте ее должным образом

Если операция не является строго необходимой,
мы можем обеспечить исправление ошибки,
но без сбоев, восстановив ее.

</td><td>

```go
if err := emitMetrics(); err != nil {
	// Невозможность записи показателей 
	// не должна приводить к прерыванию работы приложения.
  log.Printf("Could not emit metrics: %v", err)
}

```

</td></tr>
<tr><td>

**Good**: Сопоставьте ошибку и корректно устраните ее

Если вызываемый объект определяет конкретную ошибку в своем контракте
и сбой можно устранить,
сопоставьте этот случай ошибки и корректно устраните его.
Во всех остальных случаях завершите обработку ошибки и верните ее.

Вызывающие абоненты, находящиеся выше по стеку, будут обрабатывать другие ошибки.

</td><td>

```go
tz, err := getUserTimeZone(id)
if err != nil {
  if errors.Is(err, ErrUserNotFound) {
    // Пользователь не существует. Используйте UTC.
    tz = time.UTC
  } else {
    return fmt.Errorf("get user %q: %w", id, err)
  }
}
```

</td></tr>
</tbody></table>

### Обработать ошибки при подтверждении типа

Форма с единственным возвращаемым значением [утверждение типа](https://go.dev/ref/spec#Type_assertions) будет запаниковывать при вводе неправильного
типа. Поэтому всегда используйте идиому "запятая в порядке".

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
t := i.(string)
```

</td><td>

```go
t, ok := i.(string)
if !ok {
  // handle the error gracefully
}
```

</td></tr>
</tbody></table>

<!-- TODO: There are a few situations where the single assignment form is
fine. -->

### Не паникуйте

Код, запущенный в рабочей среде, должен избегать паники. Паника является основным источником
[каскадных сбоев]. При возникновении ошибки функция должна вернуть сообщение об ошибке и
позволить вызывающей стороне решить, как с этим справиться.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
func run(args []string) {
  if len(args) == 0 {
    panic("an argument is required")
  }
  // ...
}

func main() {
  run(os.Args[1:])
}
```

</td><td>

```go
func run(args []string) error {
  if len(args) == 0 {
    return errors.New("an argument is required")
  }
  // ...
  return nil
}

func main() {
  if err := run(os.Args[1:]); err != nil {
    fmt.Fprintln(os.Stderr, err)
    os.Exit(1)
  }
}
```

</td></tr>
</tbody></table>

Panic/recovery не является стратегией обработки ошибок. Программа должна паниковать только тогда, когда
происходит что-то непоправимое, например, нулевое разыменование. Исключением из этого правила является
инициализация программы: сбои при запуске программы, которые должны привести к прерыванию работы
программы, могут вызвать панику.

```go
var _statusTemplate = template.Must(template.New("name").Parse("_statusHTML"))
```

Даже в тестах отдавайте предпочтение `t.Fatal` или `t.FailNow`, а не `panics`, чтобы убедиться, что
тест помечен как неудачный.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
// func TestFoo(t *testing.T)

f, err := os.CreateTemp("", "test")
if err != nil {
  panic("failed to set up test")
}
```

</td><td>

```go
// func TestFoo(t *testing.T)

f, err := os.CreateTemp("", "test")
if err != nil {
  t.Fatal("failed to set up test")
}
```

</td></tr>
</tbody></table>

### Используй go.uber.org/atomic

Атомарные операции с пакетом [sync/atomic](https://pkg.go.dev/sync/atomic) работают с необработанными типами
(`int32`, `int64` и т.д.), поэтому легко забыть использовать атомарную операцию для
чтения или изменения переменных.

[go.uber.org/atomic](https://pkg.go.dev/go.uber.org/atomic) повышает безопасность этих операций, скрывая
базовый тип. Кроме того, он включает удобный тип `atomic.Bool`.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
type foo struct {
  running int32  // atomic
}

func (f* foo) start() {
  if atomic.SwapInt32(&f.running, 1) == 1 {
     // already running…
     return
  }
  // start the Foo
}

func (f *foo) isRunning() bool {
  return f.running == 1  // race!
}
```

</td><td>

```go
type foo struct {
  running atomic.Bool
}

func (f *foo) start() {
  if f.running.Swap(true) {
     // already running…
     return
  }
  // start the Foo
}

func (f *foo) isRunning() bool {
  return f.running.Load()
}
```

</td></tr>
</tbody></table>

### Избегайте изменяемых глобальных переменных

Избегайте изменения глобальных переменных, вместо этого выбирайте внедрение зависимостей.
Это относится как к указателям на функции, так и к другим типам значений.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
// sign.go

var _timeNow = time.Now

func sign(msg string) string {
  now := _timeNow()
  return signWithTime(msg, now)
}
```

</td><td>

```go
// sign.go

type signer struct {
  now func() time.Time
}

func newSigner() *signer {
  return &signer{
    now: time.Now,
  }
}

func (s *signer) Sign(msg string) string {
  now := s.now()
  return signWithTime(msg, now)
}
```

</td></tr>
<tr><td>

```go
// sign_test.go

func TestSign(t *testing.T) {
  oldTimeNow := _timeNow
  _timeNow = func() time.Time {
    return someFixedTime
  }
  defer func() { _timeNow = oldTimeNow }()

  assert.Equal(t, want, sign(give))
}
```

</td><td>

```go
// sign_test.go

func TestSigner(t *testing.T) {
  s := newSigner()
  s.now = func() time.Time {
    return someFixedTime
  }

  assert.Equal(t, want, s.Sign(give))
}
```

</td></tr>
</tbody></table>

### Избегайте встраивания типов в общедоступные структуры

Эти встроенные типы приводят к утечке информации о реализации, препятствуют эволюции типов и
скрывают документацию.

Предполагая, что вы реализовали множество типов списков, используя общий
"AbstractList", избегайте встраивания "AbstractList" в ваши конкретные
реализации списков.
Вместо этого от руки запишите в свой конкретный список только те методы, которые будут делегированы
абстрактному списку.

```go
type AbstractList struct {}

// Add добавляет объект в список.
func (l *AbstractList) Add(e Entity) {
  // ...
}

// Remove удаляет объект из списка.
func (l *AbstractList) Remove(e Entity) {
  // ...
}
```

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
// ConcreteList - это список сущностей.
type ConcreteList struct {
  *AbstractList
}
```

</td><td>

```go
// ConcreteList - это список сущностей.
type ConcreteList struct {
  list *AbstractList
}

// Add добавляет объект в список.
func (l *ConcreteList) Add(e Entity) {
  l.list.Add(e)
}

// Remove удаляет объект из списка.
func (l *ConcreteList) Remove(e Entity) {
  l.list.Remove(e)
}
```

</td></tr>
</tbody></table>

Go допускает [type embedding](https://go.dev/doc/effective_go#embedding) в качестве компромисса между наследованием и композицией.
Внешний тип получает неявные копии методов встроенного типа.
Эти методы по умолчанию делегируются тому же методу встроенного
экземпляра.

Структура также получает поле с тем же именем, что и тип.
Таким образом, если встроенный тип является общедоступным, то и поле будет общедоступным.
Для обеспечения обратной совместимости каждая будущая версия внешнего типа должна
сохранять встроенный тип.

Встроенный тип редко бывает необходим.
Это удобство, которое помогает вам избежать написания утомительных методов делегирования.

Даже внедрение совместимого интерфейса AbstractList *interface* вместо struct
предоставило бы разработчику больше гибкости для внесения изменений в будущем, но все равно
привело бы к утечке информации о том, что конкретные списки используют абстрактную реализацию.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
// AbstractList - это обобщенная реализация
// для различных видов списков сущностей.
type AbstractList interface {
  Add(Entity)
  Remove(Entity)
}

// ConcreteList - это список сущностей.
type ConcreteList struct {
  AbstractList
}
```

</td><td>

```go
// ConcreteList is a list of entities.
type ConcreteList struct {
  list AbstractList
}

// Add adds an entity to the list.
func (l *ConcreteList) Add(e Entity) {
  l.list.Add(e)
}

// Remove removes an entity from the list.
func (l *ConcreteList) Remove(e Entity) {
  l.list.Remove(e)
}
```

</td></tr>
</tbody></table>

Как во встроенной структуре, так и во встроенном интерфейсе встроенный тип
накладывает ограничения на эволюцию типа.

- Добавление методов во встроенный интерфейс является кардинальным изменением.
- Удаление методов из встроенной структуры является кардинальным изменением.
- Удаление встроенного типа является кардинальным изменением.
- Замена встроенного типа даже на альтернативный, удовлетворяющий тем же требованиям.
  интерфейс - это кардинальное изменение.

Хотя написание этих методов делегирования является утомительным занятием, дополнительные усилия скрывают
детали реализации, оставляют больше возможностей для изменений, а также
устраняет косвенные ссылки для поиска полного интерфейса списка в
документации.

### Избегайте использования встроенных имен

В [языковой спецификации Go] описаны несколько встроенных
[предопределенных идентификаторов], которые не следует использовать в качестве имен в программах Go.

В зависимости от контекста повторное использование этих идентификаторов в качестве имен либо затеняет
оригинал в текущей лексической области (и любых вложенных областях), либо
приводит к путанице в коде. В лучшем случае компилятор будет жаловаться; в
худшем случае такой код может содержать скрытые, трудно поддающиеся исправлению ошибки.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
var error string
// `error` shadows the builtin

// or

func handleErrorMessage(error string) {
    // `error` shadows the builtin
}
```

</td><td>

```go
var errorMessage string
// `error` refers to the builtin

// or

func handleErrorMessage(msg string) {
    // `error` refers to the builtin
}
```

</td></tr>
<tr><td>

```go
type Foo struct {
    // While these fields technically don't
    // constitute shadowing, grepping for
    // `error` or `string` strings is now
    // ambiguous.
    error  error
    string string
}

func (f Foo) Error() error {
    // `error` and `f.error` are
    // visually similar
    return f.error
}

func (f Foo) String() string {
    // `string` and `f.string` are
    // visually similar
    return f.string
}
```

</td><td>

```go
type Foo struct {
    // `error` and `string` strings are
    // now unambiguous.
    err error
    str string
}

func (f Foo) Error() error {
    return f.err
}

func (f Foo) String() string {
    return f.str
}
```

</td></tr>
</tbody></table>

Note that the compiler will not generate errors when using predeclared
identifiers, but tools such as `go vet` should correctly point out these and
other cases of shadowing.

### Избегайте `init()`

По возможности избегайте `init()`. Когда `init()` неизбежен или желателен, код
должен попытаться это сделать:

1. Быть полностью детерминированным, независимо от программной среды или вызова.
2. Избегайте зависимости от порядка выполнения или побочных эффектов других функций init().
   Хотя порядок выполнения init() хорошо известен, код может меняться, и, следовательно,
   взаимосвязи между функциями init() могут сделать код хрупким и
   подверженным ошибкам.
3. Избегайте доступа к глобальным данным или состоянию среды или манипулирования ими, таким как машинная
   информация, переменные среды, рабочий каталог, программа
   аргументы/входные данные и т.д.
4. Избегайте операций ввода-вывода, включая вызовы файловой системы, сети и системные вызовы.

Код, который не может удовлетворить этим требованиям, скорее всего, является вспомогательным и должен
вызываться как часть функции main() (или где-либо еще в жизненном цикле программы) или быть
написан как часть самой функции main(). В частности, библиотеки, предназначенные
для использования другими программами, должны быть полностью
детерминированными и не выполнять "магию инициализации".

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
type Foo struct {
    // ...
}

var _defaultFoo Foo

func init() {
    _defaultFoo = Foo{
        // ...
    }
}
```

</td><td>

```go
var _defaultFoo = Foo{
    // ...
}

// или, что еще лучше, для удобства тестирования:

var _defaultFoo = defaultFoo()

func defaultFoo() Foo {
    return Foo{
        // ...
    }
}
```

</td></tr>
<tr><td>

```go
type Config struct {
    // ...
}

var _config Config

func init() {
    // Bad: на основе текущего каталога
    cwd, _ := os.Getwd()

    // Bad: I/O
    raw, _ := os.ReadFile(
        path.Join(cwd, "config", "config.yaml"),
    )

    yaml.Unmarshal(raw, &_config)
}
```

</td><td>

```go
type Config struct {
    // ...
}

func loadConfig() Config {
    cwd, err := os.Getwd()
    // handle err

    raw, err := os.ReadFile(
        path.Join(cwd, "config", "config.yaml"),
    )
    // handle err

    var config Config
    yaml.Unmarshal(raw, &config)

    return config
}
```

</td></tr>
</tbody></table>

Учитывая вышесказанное, некоторые ситуации, в которых использование it() может быть предпочтительным или
необходимым, могут включать в себя:

- Сложные выражения, которые нельзя представить в виде отдельных назначений.
- Подключаемые перехватчики, такие как диалекты базы данных/sql, реестры типов кодировок и т.д.
- Оптимизация [облачных функций Google] и других форм детерминированных
  предварительных вычислений.

### Завершите работу в главном меню

Для немедленного завершения работы в программах Go используйте [`os.Exit`](https://pkg.go.dev/os#Exit) или [`log.Fatal*`](https://pkg.go.dev/log#Fatal). (Паника
- не лучший способ выхода из программ, пожалуйста, [не паникуйте](#%D0%BD%D0%B5-%D0%BF%D0%B0%D0%BD%D0%B8%D0%BA%D1%83%D0%B9%D1%82%D0%B5).)
- 

Вызовите одну из `os.Exit` или `log.Fatal*` **только в `main()`**. Все остальные
функции должны возвращать ошибки, сигнализирующие о сбое.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
func main() {
  body := readFile(path)
  fmt.Println(body)
}

func readFile(path string) string {
  f, err := os.Open(path)
  if err != nil {
    log.Fatal(err)
  }

  b, err := io.ReadAll(f)
  if err != nil {
    log.Fatal(err)
  }

  return string(b)
}
```

</td><td>

```go
func main() {
  body, err := readFile(path)
  if err != nil {
    log.Fatal(err)
  }
  fmt.Println(body)
}

func readFile(path string) (string, error) {
  f, err := os.Open(path)
  if err != nil {
    return "", err
  }

  b, err := io.ReadAll(f)
  if err != nil {
    return "", err
  }

  return string(b), nil
}
```

</td></tr>
</tbody></table>

Обоснование: Программы с несколькими функциями, которые завершают работу, создают несколько проблем:

- Неочевидный поток управления: любая функция может завершить работу программы, поэтому становится
  трудно разобраться в потоке управления.
- Сложно протестировать: функция, которая завершает работу программы, также завершит тест
  , вызывающий ее. Это затрудняет тестирование функции и создает риск
  пропуска других тестов, которые еще не были запущены с помощью "go test".
- Пропущенная очистка: когда функция выходит из программы, она пропускает вызовы функций
  помещается в очередь с инструкциями `отложить`. Это увеличивает риск пропуска важных
  задач по очистке.

#### Завершите работу один раз

Если возможно, предпочтите вызывать "os.Exit" или "log.Fatal" **не более одного раза ** в вашем
`main()`. Если существует несколько сценариев возникновения ошибок, которые останавливают выполнение программы,
выделите эту логику в отдельную функцию и возвращайте ошибки из нее.

Это сокращает вашу функцию `main()` и помещает всю ключевую
бизнес-логику в отдельную тестируемую функцию.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
package main

func main() {
  args := os.Args[1:]
  if len(args) != 1 {
    log.Fatal("missing file")
  }
  name := args[0]

  f, err := os.Open(name)
  if err != nil {
    log.Fatal(err)
  }
  defer f.Close()

	// Если мы вызовем log.Fatal после этой строки,
	// f.Close вызываться не будет.

  b, err := io.ReadAll(f)
  if err != nil {
    log.Fatal(err)
  }

  // ...
}
```

</td><td>

```go
package main

func main() {
  if err := run(); err != nil {
    log.Fatal(err)
  }
}

func run() error {
  args := os.Args[1:]
  if len(args) != 1 {
    return errors.New("missing file")
  }
  name := args[0]

  f, err := os.Open(name)
  if err != nil {
    return err
  }
  defer f.Close()

  b, err := io.ReadAll(f)
  if err != nil {
    return err
  }

  // ...
}
```

</td></tr>
</tbody></table>

В приведенном выше примере используется `log.Fatal`, но это руководство также применимо к
"os.Exit" или любому библиотечному коду, который вызывает "os.Exit`.

```go
func main() {
  if err := run(); err != nil {
    fmt.Fprintln(os.Stderr, err)
    os.Exit(1)
  }
}
```

Вы можете изменить сигнатуру `run()` в соответствии с вашими потребностями.
Например, если ваша программа должна завершать работу с определенными кодами завершения при сбоях,
`run()` может возвращать код завершения вместо ошибки.
Это позволяет модульным тестам также проверять это поведение напрямую.

```go
func main() {
  os.Exit(run(args))
}

func run() (exitCode int) {
  // ...
}
```

В целом, обратите внимание, что функция `run()`, используемая в этих примерах
, не является обязательной.
В названии, подписи и настройках функции `run()` предусмотрена гибкость.
Помимо прочего, вы можете:

- принимать нераспечатанные аргументы командной строки (например, `run(os.Args[1:])`)
- анализировать аргументы командной строки в `main()` и передавать их в `run`
- используйте пользовательский тип ошибки, чтобы перенести код завершения обратно в "main()"
- перенесите бизнес-логику на другой уровень абстракции, отличный от "package main"

Это руководство требует, чтобы в вашем "main()" было только одно место.
ответственный за фактический выход из процесса.

### Используйте теги полей в упорядоченных структурах

Любое структурное поле, которое преобразуется в JSON, YAML
или другие форматы, поддерживающие именование полей на основе тегов,
должно быть помечено соответствующим тегом.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
type Stock struct {
  Price int
  Name  string
}

bytes, err := json.Marshal(Stock{
  Price: 137,
  Name:  "UBER",
})
```

</td><td>

```go
type Stock struct {
  Price int    `json:"price"`
  Name  string `json:"name"`
  // Безопасно переименовать имя в символ.
}

bytes, err := json.Marshal(Stock{
  Price: 137,
  Name:  "UBER",
})
```

</td></tr>
</tbody></table>

Обоснование:
Сериализованная форма структуры представляет собой контракт между различными системами.
Изменения в структуре сериализованной формы, включая названия полей, нарушают
этот контракт. Указание имен полей внутри тегов делает контракт явным
и защищает от случайного нарушения контракта путем рефакторинга или
переименования полей.

### Не запускайте и не забывайте о подпрограммах

Подпрограммы просты, но они не бесплатны:
как минимум, они требуют памяти для своего стека и центрального процессора для планирования.
Несмотря на то, что эти затраты невелики при обычном использовании подпрограмм,
они могут вызвать значительные проблемы с производительностью
при запуске в больших количествах без контролируемого времени жизни.
Программы с неуправляемым временем жизни также могут вызывать другие проблемы
, например, предотвращать сборку мусора для неиспользуемых объектов
и сохранять ресурсы, которые в противном случае больше не используются.

Поэтому не допускайте утечки программ в рабочий код.
Используйте [go.uber.org/goleak](https://pkg.go.dev/go.uber.org/goleak)
для проверки на наличие утечек в программах внутри пакетов, которые могут вызывать такие программы.

В общем, каждая программа:

- должна иметь предсказуемое время, когда она перестанет выполняться; или
- должен быть способ подать программе сигнал о том, что она должна остановиться

В обоих случаях должен быть код для блокировки и ожидания
завершения работы программы.

Например:

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
go func() {
  for {
    flush()
    time.Sleep(delay)
  }
}()
```

</td><td>

```go
var (
  stop = make(chan struct{}) // tells the goroutine to stop
  done = make(chan struct{}) // tells us that the goroutine exited
)
go func() {
  defer close(done)

  ticker := time.NewTicker(delay)
  defer ticker.Stop()
  for {
    select {
    case <-ticker.C:
      flush()
    case <-stop:
      return
    }
  }
}()

// Elsewhere...
close(stop)  // signal the goroutine to stop
<-done       // and wait for it to exit
```

</td></tr>
<tr><td>

Остановить эту процедуру невозможно.
Она будет выполняться до завершения работы приложения.

</td><td>

Эту подпрограмму можно остановить с помощью `закрыть (stop)`,
и мы не можем ждать, пока она завершится с помощью `<-done`.

</td></tr>
</tbody></table>

#### Дождитесь завершения работы подпрограммы

Учитывая, что система запускает подпрограмму,
должен быть способ дождаться завершения работы подпрограммы.
Есть два популярных способа сделать это:

- Используйте `sync.WaitGroup`.
  Сделайте это, если есть несколько подпрограмм, выполнения которых вы хотите дождаться

  ```go
  var wg sync.WaitGroup
  for i := 0; i < N; i++ {
    wg.Add(1)
    go func() {
      defer wg.Done()
      // ...
    }()
  }

  // To wait for all to finish:
  wg.Wait()
  ```

- Добавьте еще одну `chan struct{}`, которую программа закрывает по завершении работы.
  Сделайте это, если есть только одна программа.

  ```go
  done := make(chan struct{})
  go func() {
    defer close(done)
    // ...
  }()

  // Дождаться завершения работы программы:
  <-done
  ```

#### Никаких подпрограмм в `init()`

Функции `init()` не должны создавать подпрограммы.
Смотрите также [Избегайте init()](#%D0%B8%D0%B7%D0%B1%D0%B5%D0%B3%D0%B0%D0%B9%D1%82%D0%B5-init).

Если пакету требуется фоновая подпрограмма,
он должен предоставить доступ к объекту, который отвечает за управление временем
жизни подпрограмм.
Объект должен предоставлять метод (`Close`, `Stop`, `Shutdown`, и т.д.).
это сигнализирует об остановке фоновой программы и ожидает ее завершения.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
func init() {
  go doWork()
}

func doWork() {
  for {
    // ...
  }
}
```

</td><td>

```go
type Worker struct{ /* ... */ }

func NewWorker(...) *Worker {
  w := &Worker{
    stop: make(chan struct{}),
    done: make(chan struct{}),
    // ...
  }
  go w.doWork()
}

func (w *Worker) doWork() {
  defer close(w.done)
  for {
    // ...
    case <-w.stop:
      return
  }
}

// Shutdown приказывает работнику остановиться
// и ждет, пока он не завершит работу.
func (w *Worker) Shutdown() {
  close(w.stop)
  <-w.done
}
```

</td></tr>
<tr><td>

Запускает фоновую подпрограмму без каких-либо условий, когда пользователь экспортирует этот пакет.
Пользователь не имеет никакого контроля над подпрограммой или средств ее остановки.

</td><td>

Запускает worker только по запросу пользователя.
Предоставляет средство завершения работы worker, чтобы пользователь мог освободить
ресурсы, используемые worker.

Обратите внимание, что вам следует использовать "WaitGroup", если worker управляет несколькими
подпрограммами.
Смотрите [Дождитесь завершения выполнения подпрограммы](#%D0%B4%D0%BE%D0%B6%D0%B4%D0%B8%D1%82%D0%B5%D1%81%D1%8C-%D0%B7%D0%B0%D0%B2%D0%B5%D1%80%D1%88%D0%B5%D0%BD%D0%B8%D1%8F-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B-%D0%BF%D0%BE%D0%B4%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D1%8B).

</td></tr>
</tbody></table>

## Производительность

Рекомендации, касающиеся производительности, применимы только к горячему контуру.

### Предпочитайте strconv, а не fmt

При преобразовании примитивов в строки и из них "strconv" работает быстрее, чем
`fmt`.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
for i := 0; i < b.N; i++ {
  s := fmt.Sprint(rand.Int())
}
```

</td><td>

```go
for i := 0; i < b.N; i++ {
  s := strconv.Itoa(rand.Int())
}
```

</td></tr>
<tr><td>

```plain
BenchmarkFmtSprint-4    143 ns/op    2 allocs/op
```

</td><td>

```plain
BenchmarkStrconv-4    64.2 ns/op    1 allocs/op
```

</td></tr>
</tbody></table>

### Избегайте повторных преобразований строк в байты

Не создавайте байтовые фрагменты из фиксированной строки повторно. Вместо этого выполните
преобразование один раз и зафиксируйте результат.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
for i := 0; i < b.N; i++ {
  w.Write([]byte("Hello world"))
}
```

</td><td>

```go
data := []byte("Hello world")
for i := 0; i < b.N; i++ {
  w.Write(data)
}
```

</td></tr>
<tr><td>

```plain
BenchmarkBad-4   50000000   22.2 ns/op
```

</td><td>

```plain
BenchmarkGood-4  500000000   3.25 ns/op
```

</td></tr>
</tbody></table>

### Предпочтительнее указывать емкость контейнера

По возможности указывайте емкость контейнера, чтобы заранее выделить память для
контейнера. Это сводит к минимуму последующие выделения (путем копирования и
изменения размера контейнера) по мере добавления элементов.

#### Указание емкости карты дает подсказки

Там, где это возможно, указывайте емкость при инициализации
карт с помощью `make()`.

```go
make(map[T1]T2, hint)
```

Предоставляя подсказку о емкости для `make()`, вы пытаетесь настроить правильный размер
карты во время инициализации, что уменьшает необходимость в увеличении
карты и распределении ресурсов по мере добавления элементов на карту.

Обратите внимание, что, в отличие от фрагментов, подсказки о емкости карты не гарантируют полного и
упреждающего распределения, а используются для приблизительного определения количества требуемых сегментов
хэш-карты. Следовательно, при добавлении элементов на карту все равно могут происходить перераспределения
, даже до указанной емкости.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
m := make(map[string]os.FileInfo)

files, _ := os.ReadDir("./files")
for _, f := range files {
    m[f.Name()] = f
}
```

</td><td>

```go

files, _ := os.ReadDir("./files")

m := make(map[string]os.DirEntry, len(files))
for _, f := range files {
    m[f.Name()] = f
}
```

</td></tr>
<tr><td>

`m` создается без указания размера; во время назначения может быть выделено больше
ресурсов.

</td><td>

`m` создается с указанием размера; во время назначения может быть выделено меньше
ресурсов.

</td></tr>
</tbody></table>

#### Указание емкости среза

По возможности указывайте емкость при инициализации срезов с помощью "make()",
особенно при добавлении.

```go
make([]T, length, capacity)
```

В отличие от maps, емкость фрагмента не является подсказкой: компилятор выделит достаточно
памяти для емкости фрагмента, как указано в `make()`, что означает, что
последующие операции `append()` не будут требовать выделения нулевого объема (до тех пор, пока длина
фрагмента не будет соответствовать емкости, после чего любое добавление потребуется изменить размер
для размещения дополнительных элементов).

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
for n := 0; n < b.N; n++ {
  data := make([]int, 0)
  for k := 0; k < size; k++{
    data = append(data, k)
  }
}
```

</td><td>

```go
for n := 0; n < b.N; n++ {
  data := make([]int, 0, size)
  for k := 0; k < size; k++{
    data = append(data, k)
  }
}
```

</td></tr>
<tr><td>

```plain
BenchmarkBad-4    100000000    2.48s
```

</td><td>

```plain
BenchmarkGood-4   100000000    0.21s
```

</td></tr>
</tbody></table>

## Стиль

### Избегайте слишком длинных строк

Избегайте строк кода, которые требуют от читателей прокрутки по горизонтали
или чрезмерного поворота головы.

Мы рекомендуем ограничивать длину строки не более чем **99 символами **.
Авторам следует стремиться к завершению строк до достижения этого предела,
но это не является жестким ограничением.
Коду разрешено превышать этот предел.

### Будьте последовательны

Некоторые рекомендации, изложенные в этом документе, можно оценить объективно;
другие основаны на ситуации, контексте или субъективны.

Прежде всего, ** будьте последовательны**.

Согласованный код проще в обслуживании, его легче рационализировать, он требует меньше
когнитивных затрат и его легче переносить или обновлять по мере появления новых соглашений
или исправления классов ошибок.

И наоборот, наличие нескольких разрозненных или конфликтующих стилей в рамках одной
кодовой базы приводит к накладным расходам на обслуживание, неопределенности и когнитивному диссонансу,
все это может напрямую способствовать снижению скорости работы, болезненным проверкам кода
и появлению ошибок.

При применении этих рекомендаций к кодовой базе рекомендуется вносить изменения
на уровне пакета (или более крупного пакета): приложение на уровне подпакета
нарушает вышеуказанное требование, вводя несколько стилей в один и тот же код.

### Группировать похожие объявления

Go поддерживает группирование похожих объявлений.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
import "a"
import "b"
```

</td><td>

```go
import (
  "a"
  "b"
)
```

</td></tr>
</tbody></table>

This also applies to constants, variables, and type declarations.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go

const a = 1
const b = 2



var a = 1
var b = 2



type Area float64
type Volume float64
```

</td><td>

```go
const (
  a = 1
  b = 2
)

var (
  a = 1
  b = 2
)

type (
  Area float64
  Volume float64
)
```

</td></tr>
</tbody></table>

Only group related declarations. Do not group declarations that are unrelated.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
type Operation int

const (
  Add Operation = iota + 1
  Subtract
  Multiply
  EnvVar = "MY_ENV"
)
```

</td><td>

```go
type Operation int

const (
  Add Operation = iota + 1
  Subtract
  Multiply
)

const EnvVar = "MY_ENV"
```

</td></tr>
</tbody></table>

Groups are not limited in where they can be used. For example, you can use them
inside of functions.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
func f() string {
  red := color.New(0xff0000)
  green := color.New(0x00ff00)
  blue := color.New(0x0000ff)

  // ...
}
```

</td><td>

```go
func f() string {
  var (
    red   = color.New(0xff0000)
    green = color.New(0x00ff00)
    blue  = color.New(0x0000ff)
  )

  // ...
}
```

</td></tr>
</tbody></table>

Exception: Variable declarations, particularly inside functions, should be
grouped together if declared adjacent to other variables. Do this for variables
declared together even if they are unrelated.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
func (c *client) request() {
  caller := c.name
  format := "json"
  timeout := 5*time.Second
  var err error

  // ...
}
```

</td><td>

```go
func (c *client) request() {
  var (
    caller  = c.name
    format  = "json"
    timeout = 5*time.Second
    err error
  )

  // ...
}
```

</td></tr>
</tbody></table>

### Упорядочение групп импорта

Должно быть две группы импорта:

- Стандартная библиотека
- Все остальное

Это группировка, применяемая goimports по умолчанию.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
import (
  "fmt"
  "os"
  "go.uber.org/atomic"
  "golang.org/x/sync/errgroup"
)
```

</td><td>

```go
import (
  "fmt"
  "os"

  "go.uber.org/atomic"
  "golang.org/x/sync/errgroup"
)
```

</td></tr>
</tbody></table>

### Имена пакетов

При присвоении имен пакетам выбирайте такие имена, которые:

- Все в нижнем регистре. Без заглавных букв и подчеркиваний.
- Не требует переименования с помощью именованного импорта на большинстве сайтов вызова.
- Короткие и емкие. Помните, что имя указывается полностью на каждом
  сайте вызова.
- Не во множественном числе. Например, `net/url`, а не `net/urls`.
- Не "common", "util", "shared" или "lib". Это неправильные, неинформативные названия.

Смотрите также [Названия пакетов](https://go.dev/blog/package-names) и [Рекомендации по стилю для пакетов Go](https://rakyll.org/style-packages/).

### Имена функций

Мы придерживаемся принятого в сообществе Go правила использования [смешанных заглавных букв для
имен функций]. Исключение сделано для тестовых функций, которые могут содержать символы подчеркивания
с целью группировки связанных тестовых примеров, например,
`TestMyFunction_WhatIsBeingTested`.

### Сглаживание при импорте

Сглаживание при импорте необходимо использовать, если имя пакета не совпадает с последним
элементом пути импорта.

```go
import (
  "net/http"

  client "example.com/client-go"
  trace "example.com/trace/v2"
)
```

Во всех других сценариях следует избегать использования псевдонимов импорта, если
только между импортируемыми данными нет прямого конфликта.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
import (
  "fmt"
  "os"
  runtimetrace "runtime/trace"

  nettrace "golang.net/x/trace"
)
```

</td><td>

```go
import (
  "fmt"
  "os"
  "runtime/trace"

  nettrace "golang.net/x/trace"
)
```

</td></tr>
</tbody></table>

### Группировка и упорядочение функций

- Функции должны быть отсортированы в приблизительном порядке вызова.
- Функции в файле должны быть сгруппированы по получателю.

Поэтому экспортируемые функции должны отображаться в файле первыми, после
определений `struct`, `const`, `var`.

`new XYZ()`/`NewXYZ()` может появиться после определения типа, но перед
остальными методами в получателе.

Поскольку функции сгруппированы по получателю, простые служебные функции должны отображаться
ближе к концу файла.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
func (s *something) Cost() {
  return calcCost(s.weights)
}

type something struct{ ... }

func calcCost(n []int) int {...}

func (s *something) Stop() {...}

func newSomething() *something {
    return &something{}
}
```

</td><td>

```go
type something struct{ ... }

func newSomething() *something {
    return &something{}
}

func (s *something) Cost() {
  return calcCost(s.weights)
}

func (s *something) Stop() {...}

func calcCost(n []int) int {...}
```

</td></tr>
</tbody></table>

### Уменьшить вложенность

Код должен по возможности уменьшать вложенность, сначала обрабатывая случаи ошибок/ особые
условия и возвращая их на ранней стадии или продолжая цикл. Уменьшите объем
кода, который вложен на нескольких уровнях.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
for _, v := range data {
  if v.F1 == 1 {
    v = process(v)
    if err := v.Call(); err == nil {
      v.Send()
    } else {
      return err
    }
  } else {
    log.Printf("Invalid v: %v", v)
  }
}
```

</td><td>

```go
for _, v := range data {
  if v.F1 != 1 {
    log.Printf("Invalid v: %v", v)
    continue
  }

  v = process(v)
  if err := v.Call(); err != nil {
    return err
  }
  v.Send()
}
```

</td></tr>
</tbody></table>

### Необязательный элемент Else

Если переменная задана в обеих ветвях if, ее можно заменить на
один if.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
var a int
if b {
  a = 100
} else {
  a = 10
}
```

</td><td>

```go
a := 10
if b {
  a = 100
}
```

</td></tr>
</tbody></table>

### Объявления переменных верхнего уровня

На верхнем уровне используйте стандартное ключевое слово `var`. Не указывайте тип,
если только он не совпадает с типом выражения.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
var _s string = F()

func F() string { return "A" }
```

</td><td>

```go
var _s = F()
// Поскольку F уже указывает, что возвращает строку, 
// нам не нужно снова указывать тип.

func F() string { return "A" }
```

</td></tr>
</tbody></table>

Укажите тип, если тип выражения не совсем соответствует требуемому типу.

```go
type myError struct{}

func (myError) Error() string { return "error" }

func F() myError { return myError{} }

var _e error = F()
// F возвращает объект типа MyError, но нам нужна ошибка.
```

### Добавляйте к неэкспортируемым глобальным символам префикс _

Добавляйте к неэкспортируемым символам верхнего уровня "var" и "const" префикс "_", чтобы при
их использовании было ясно, что они являются глобальными символами.

Обоснование: Переменные и константы верхнего уровня имеют область действия пакета. Использование
общего имени позволяет легко случайно использовать неправильное значение в другом
файле.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
// foo.go

const (
  defaultPort = 8080
  defaultUser = "user"
)

// bar.go

func Bar() {
  defaultPort := 9090
  ...
  fmt.Println("Default port", defaultPort)

  // We will not see a compile error if the first line of
  // Bar() is deleted.
}
```

</td><td>

```go
// foo.go

const (
  _defaultPort = 8080
  _defaultUser = "user"
)
```

</td></tr>
</tbody></table>

**Исключение**: В неэкспортированных значениях ошибок может использоваться префикс `err` без подчеркивания.
Смотрите [Наименование ошибки](#%D0%BF%D1%80%D0%B8%D1%81%D0%B2%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B8%D0%BC%D0%B5%D0%BD-%D0%BE%D1%88%D0%B8%D0%B1%D0%BA%D0%B0%D0%BC).

### # Встраивание в структуры

Встроенные типы должны располагаться в верхней части списка полей
структуры, и должна быть пустая строка, отделяющая встроенные поля от обычных.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
type Client struct {
  version int
  http.Client
}
```

</td><td>

```go
type Client struct {
  http.Client

  version int
}
```

</td></tr>
</tbody></table>

Внедрение должно приносить ощутимую пользу, например, добавлять или расширять
функциональность семантически приемлемым способом. Это должно происходить с нулевым
негативным воздействием на пользователя (см. также: [Избегайте внедрения типов в общедоступные структуры](#%D0%B8%D0%B7%D0%B1%D0%B5%D0%B3%D0%B0%D0%B9%D1%82%D0%B5-%D0%B2%D1%81%D1%82%D1%80%D0%B0%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2-%D0%B2-%D0%BE%D0%B1%D1%89%D0%B5%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%BD%D1%8B%D0%B5-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B)).

Исключение: Мьютексы не должны встраиваться даже в неэкспортируемые типы. Смотрите также: [Допустимы мьютексы с нулевым значением](#%D0%B4%D0%BE%D0%BF%D1%83%D1%81%D1%82%D0%B8%D0%BC%D1%8B-%D0%BC%D1%8C%D1%8E%D1%82%D0%B5%D0%BA%D1%81%D1%8B-%D1%81-%D0%BD%D1%83%D0%BB%D0%B5%D0%B2%D1%8B%D0%BC-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC).

Встраивание ** не должно быть**:

- чисто косметическим или ориентированным на удобство.
- Усложняет создание или использование внешних типов.
- Влияет на нулевые значения внешних типов. Если внешний тип имеет полезное нулевое значение, он
  после внедрения внутреннего типа все равно должно быть полезное нулевое значение.
- Отображение несвязанных функций или полей из внешнего типа в качестве побочного эффекта
  внедрения внутреннего типа.
- Отображение неэкспортированных типов.
- Изменение семантики копирования внешних типов.
- Измените API внешнего типа или семантику типа.
- Внедрите неканоническую форму внутреннего типа.
- Предоставьте подробную информацию о реализации внешнего типа.
- Разрешите пользователям наблюдать за внутренними элементами типа или управлять ими.
- Измените общее поведение внутренних функций, обернув их таким образом, чтобы это
  могло приятно удивить пользователей.

Проще говоря, внедряйте сознательно и преднамеренно. Хороший тест на лакмусовую бумажку заключается в следующем: "будут
ли все эти экспортированные внутренние методы/поля добавлены непосредственно во внешний тип".;
если ответ "какой-то" или "нет", не вводите внутренний тип - используйте
вместо него поле.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
type A struct {
    // Ошибка: функции A.Lock() и A.Unlock()
    // доступны в настоящее время, не предоставляют
    // функциональных преимуществ и позволяют
    // пользователям управлять подробностями о
    // внутреннем устройстве A.
    sync.Mutex
}
```

</td><td>

```go
type countingWriteCloser struct {
    // Хорошо: функция Write() предусмотрена на этом
    // внешнем уровне для определенной
    // цели и делегирует работу
    // функции Write() внутреннего типа.
    io.WriteCloser

    count int
}

func (w *countingWriteCloser) Write(bs []byte) (int, error) {
    w.count += len(bs)
    return w.WriteCloser.Write(bs)
}
```

</td></tr>
<tr><td>

```go
type Book struct {
    // Bad: указатель изменяет полезность нулевого значения
    io.ReadWriter

    // other fields
}

// later

var b Book
b.Read(...)  // panic: nil pointer
b.String()   // panic: nil pointer
b.Write(...) // panic: nil pointer
```

</td><td>

```go
type Book struct {
    // Good: имеет полезное нулевое значение
    bytes.Buffer

    // other fields
}

// later

var b Book
b.Read(...)  // ok
b.String()   // ok
b.Write(...) // ok
```

</td></tr>
<tr><td>

```go
type Client struct {
    sync.Mutex
    sync.WaitGroup
    bytes.Buffer
    url.URL
}
```

</td><td>

```go
type Client struct {
    mtx sync.Mutex
    wg  sync.WaitGroup
    buf bytes.Buffer
    url url.URL
}
```

</td></tr>
</tbody></table>

### Объявления локальных переменных

Короткие объявления переменных (`:=`) следует использовать, если переменной явно присваивается
какое-либо значение.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
var s = "foo"
```

</td><td>

```go
s := "foo"
```

</td></tr>
</tbody></table>

Однако в некоторых случаях значение по умолчанию становится более понятным, когда
используется ключевое слово `var`. Например, [Объявление пустых Slices].

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
func f(list []int) {
  filtered := []int{}
  for _, v := range list {
    if v > 10 {
      filtered = append(filtered, v)
    }
  }
}
```

</td><td>

```go
func f(list []int) {
  var filtered []int
  for _, v := range list {
    if v > 10 {
      filtered = append(filtered, v)
    }
  }
}
```

</td></tr>
</tbody></table>

### nil - допустимый фрагмент

`nil` - допустимый фрагмент длиной 0. Это означает, что,

- Вы не должны возвращать фрагмент нулевой длины явно. Возвращайте `nil`
  вместо.

  <table>
  <thead><tr><th>Bad</th><th>Good</th></tr></thead>
  <tbody>
  <tr><td>

  ```go
  if x == "" {
    return []int{}
  }
  ```

  </td><td>

  ```go
  if x == "" {
    return nil
  }
  ```

  </td></tr>
  </tbody></table>

- Чтобы проверить, пуст ли фрагмент, всегда используйте `len(s) == 0`. Не проверяйте наличие
  `nil`.

  <table>
  <thead><tr><th>Bad</th><th>Good</th></tr></thead>
  <tbody>
  <tr><td>

  ```go
  func isEmpty(s []string) bool {
    return s == nil
  }
  ```

  </td><td>

  ```go
  func isEmpty(s []string) bool {
    return len(s) == 0
  }
  ```

  </td></tr>
  </tbody></table>

- Нулевое значение (фрагмент, объявленный с помощью `var`) можно использовать немедленно без использования
  `make()`.

  <table>
  <thead><tr><th>Bad</th><th>Good</th></tr></thead>
  <tbody>
  <tr><td>

  ```go
  nums := []int{}
  // or, nums := make([]int)

  if add1 {
    nums = append(nums, 1)
  }

  if add2 {
    nums = append(nums, 2)
  }
  ```

  </td><td>

  ```go
  var nums []int

  if add1 {
    nums = append(nums, 1)
  }

  if add2 {
    nums = append(nums, 2)
  }
  ```

  </td></tr>
  </tbody></table>

Помните, что, хотя это допустимый фрагмент, нулевой фрагмент не эквивалентен
выделенному фрагменту длиной 0 - один из них равен нулю, а другой - нет, - и в разных
ситуациях (например, при сериализации) они могут обрабатываться по-разному.

### Уменьшите область видимости переменных

По возможности уменьшите область видимости переменных и констант. Не уменьшайте область видимости, если это
противоречит [Уменьшить вложенность](#%D1%83%D0%BC%D0%B5%D0%BD%D1%8C%D1%88%D0%B8%D1%82%D1%8C-%D0%B2%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D1%8C).

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
err := os.WriteFile(name, data, 0644)
if err != nil {
 return err
}
```

</td><td>

```go
if err := os.WriteFile(name, data, 0644); err != nil {
 return err
}
```

</td></tr>
</tbody></table>

Если вам нужен результат вызова функции за пределами if, то вам не следует
пытаться уменьшить область видимости.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
if data, err := os.ReadFile(name); err == nil {
  err = cfg.Decode(data)
  if err != nil {
    return err
  }

  fmt.Println(cfg)
  return nil
} else {
  return err
}
```

</td><td>

```go
data, err := os.ReadFile(name)
if err != nil {
   return err
}

if err := cfg.Decode(data); err != nil {
  return err
}

fmt.Println(cfg)
return nil
```

</td></tr>
</tbody></table>

Константы не обязательно должны быть глобальными, если только они не используются в нескольких функциях или файлах
или не являются частью внешнего контракта пакета.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
const (
  _defaultPort = 8080
  _defaultUser = "user"
)

func Bar() {
  fmt.Println("Default port", _defaultPort)
}
```

</td><td>

```go
func Bar() {
  const (
    defaultPort = 8080
    defaultUser = "user"
  )
  fmt.Println("Default port", defaultPort)
}
```

</td></tr>
</tbody></table>

### Избегайте открытых параметров

Именованные параметры в вызовах функций могут ухудшить читаемость. Добавляйте комментарии в стиле Си
(`/* ... */`) для имен параметров, если их значение неочевидно.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
// func printInfo(name string, isLocal, done bool)

printInfo("foo", true, true)
```

</td><td>

```go
// func printInfo(name string, isLocal, done bool)

printInfo("foo", true /* isLocal */, true /* done */)
```

</td></tr>
</tbody></table>

А еще лучше, замените обычные типы `bool` пользовательскими типами для более удобочитаемого и
типобезопасного кода. В будущем для этого параметра будет разрешено не только два состояния (true/false).

```go
type Region int

const (
  UnknownRegion Region = iota
  Local
)

type Status int

const (
  StatusReady Status = iota + 1
  StatusDone
  // // Возможно, в будущем у нас будет статус InProgress.
)

func printInfo(name string, region Region, status Status)
```

### Используйте необработанные строковые литералы, чтобы избежать экранирования

Go поддерживает [необработанные строковые литералы](https://go.dev/ref/spec#raw_string_lit),
которые могут занимать несколько строк и включать кавычки. Используйте их, чтобы избежать
ручного экранирования строк, которые намного сложнее читать.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
wantError := "unknown name:\"test\""
```

</td><td>

```go
wantError := `unknown error:"test"`
```

</td></tr>
</tbody></table>

### Инициализация структур

#### Используйте имена полей для инициализации структур

При инициализации структур почти всегда следует указывать имена полей.
Теперь это поддерживается [`go vet`](https://pkg.go.dev/cmd/vet).

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
k := User{"John", "Doe", true}
```

</td><td>

```go
k := User{
    FirstName: "John",
    LastName: "Doe",
    Admin: true,
}
```

</td></tr>
</tbody></table>

Исключение: Имена полей *могут* быть опущены в тестовых таблицах, если имеется 3 или
менее полей.

```go
tests := []struct{
  op Operation
  want string
}{
  {Add, "add"},
  {Subtract, "subtract"},
}
```

#### Опустите поля с нулевыми значениями в структурах

При инициализации структур с именами полей опускайте поля с нулевыми значениями,
если только они не содержат значимого контекста. В противном случае let Go автоматически установит для них нулевые
значения.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
user := User{
  FirstName: "John",
  LastName: "Doe",
  MiddleName: "",
  Admin: false,
}
```

</td><td>

```go
user := User{
  FirstName: "John",
  LastName: "Doe",
}
```

</td></tr>
</tbody></table>

Это помогает уменьшить помехи для считывателей, опуская значения, которые используются по умолчанию в
данном контексте. Указываются только значимые значения.

Включайте нулевые значения там, где имена полей обеспечивают значимый контекст. Например,
тестовые примеры в [Тестовых таблицах](#%D1%82%D0%B5%D1%81%D1%82%D0%BE%D0%B2%D1%8B%D0%B5-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8B) могут использовать названия полей
, даже если они имеют нулевое значение.

```go
tests := []struct{
  give string
  want int
}{
  {give: "0", want: 0},
  // ...
}
```

#### Используйте `var` для структур с нулевым значением

Если в объявлении структуры опущены все поля, используйте форму `var`
для объявления структуры.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
user := User{}
```

</td><td>

```go
var user User
```

</td></tr>
</tbody></table>

Это отличает структуры с нулевым значением от структур с ненулевыми полями,
аналогично различию, созданному для [инициализации карты](#%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BA%D0%B0%D1%80%D1%82), и соответствует тому, как
мы предпочитаем [объявлять пустые фрагменты](https://go.dev/wiki/CodeReviewComments#declaring-empty-slices).

#### Инициализация ссылок на структуры

Используйте `&T{}` вместо `new(T)` при инициализации ссылок на структуры, чтобы это
соответствовало инициализации структуры.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
sval := T{Name: "foo"}

// несоответствующий
sptr := new(T)
sptr.Name = "bar"
```

</td><td>

```go
sval := T{Name: "foo"}

sptr := &T{Name: "bar"}
```

</td></tr>
</tbody></table>

### Инициализация карт

Для пустых карт и карт, заполняемых программным путем, предпочтительнее использовать "make(..)"
. Это визуально отличает инициализацию карты
от объявления и упрощает добавление
подсказок по размеру позже, если таковые имеются.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
var (
  // m1 безопасен для чтения и записи;
  // m2 будет паниковать при записи.
  m1 = map[T1]T2{}
  m2 map[T1]T2
)
```

</td><td>

```go
var (
  // m1 безопасен для чтения и записи;
  // m2 будет паниковать при записи.
  m1 = make(map[T1]T2)
  m2 map[T1]T2
)
```

</td></tr>
<tr><td>

Объявление и инициализация визуально схожи.

</td><td>

Объявление и инициализация визуально различаются.

</td></tr>
</tbody></table>

Там, где это возможно, указывайте емкость при инициализации
карт с помощью `make()`. Видеть
[Указание подсказок о вместимости карты] (container-capacity.md#указание подсказок о вместимости карты)
для получения дополнительной информации.

С другой стороны, если карта содержит фиксированный список элементов,
используйте литералы карты для инициализации карты.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
m := make(map[T1]T2, 3)
m[k1] = v1
m[k2] = v2
m[k3] = v3
```

</td><td>

```go
m := map[T1]T2{
  k1: v1,
  k2: v2,
  k3: v3,
}
```

</td></tr>
</tbody></table>

Основное эмпирическое правило заключается в использовании литералов map при добавлении фиксированного набора
элементов во время инициализации, в противном случае используйте `make` (и укажите подсказку по размеру,
если таковая имеется).

### Строки форматирования вне Printf

Если вы объявляете строки форматирования для функций в стиле Printf вне строкового
литерала, сделайте их значениями const.

Это помогает программе go vet выполнять статический анализ строки форматирования.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
msg := "unexpected values %v, %v\n"
fmt.Printf(msg, 1, 2)
```

</td><td>

```go
const msg = "unexpected values %v, %v\n"
fmt.Printf(msg, 1, 2)
```

</td></tr>
</tbody></table>

### Присвоение имен функциям в стиле Printf

Когда вы объявляете функцию в стиле Printf, убедитесь, что "go vet" может ее обнаружить
и проверить строку формата.

Это означает, что вам следует по возможности использовать предопределенные имена функций в стиле Printf.
`go vet` проверит их по умолчанию. Смотрите [Семейство Printf](https://pkg.go.dev/cmd/vet#hdr-Printf_family)
для получения дополнительной информации.

Если использование предопределенных имен не является возможным, завершите выбранное имя с помощью
f: "Wrapf", а не `Wrap`. `go vet" можно попросить проверить определенные имена в стиле "Printf"
, но они должны заканчиваться на f.

```shell
go vet -printfuncs=wrapf,statusf
```

Смотрите также [перейти к ветеринару: проверка семьи с помощью Printf](https://kuzminva.wordpress.com/2017/11/07/go-vet-printf-family-check/).

## Шаблоны

### Тестовые таблицы

Табличные тесты с [субтестами] могут быть полезным шаблоном для написания тестов
, позволяющим избежать дублирования кода, когда основная логика тестирования повторяется.

Если тестируемую систему необходимо протестировать в нескольких условиях, когда
определенные части входных и выходных данных изменяются, следует
использовать тест на основе таблиц, чтобы уменьшить избыточность и улучшить читаемость.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
// func TestSplitHostPort(t *testing.T)

host, port, err := net.SplitHostPort("192.0.2.0:8000")
require.NoError(t, err)
assert.Equal(t, "192.0.2.0", host)
assert.Equal(t, "8000", port)

host, port, err = net.SplitHostPort("192.0.2.0:http")
require.NoError(t, err)
assert.Equal(t, "192.0.2.0", host)
assert.Equal(t, "http", port)

host, port, err = net.SplitHostPort(":8000")
require.NoError(t, err)
assert.Equal(t, "", host)
assert.Equal(t, "8000", port)

host, port, err = net.SplitHostPort("1:8")
require.NoError(t, err)
assert.Equal(t, "1", host)
assert.Equal(t, "8", port)
```

</td><td>

```go
// func TestSplitHostPort(t *testing.T)

tests := []struct{
  give     string
  wantHost string
  wantPort string
}{
  {
    give:     "192.0.2.0:8000",
    wantHost: "192.0.2.0",
    wantPort: "8000",
  },
  {
    give:     "192.0.2.0:http",
    wantHost: "192.0.2.0",
    wantPort: "http",
  },
  {
    give:     ":8000",
    wantHost: "",
    wantPort: "8000",
  },
  {
    give:     "1:8",
    wantHost: "1",
    wantPort: "8",
  },
}

for _, tt := range tests {
  t.Run(tt.give, func(t *testing.T) {
    host, port, err := net.SplitHostPort(tt.give)
    require.NoError(t, err)
    assert.Equal(t, tt.wantHost, host)
    assert.Equal(t, tt.wantPort, port)
  })
}
```

</td></tr>
</tbody></table>

Тестовые таблицы упрощают добавление контекста к сообщениям об ошибках, сокращают дублирование
логики и добавляют новые тестовые примеры.

Мы придерживаемся соглашения о том, что фрагмент структур называется "тестами"
, а каждый тестовый пример - `tt`. Кроме того, мы рекомендуем пояснять входные и выходные
значения для каждого тестового примера с помощью префиксов `give` и `want`.

```go
tests := []struct{
  give     string
  wantHost string
  wantPort string
}{
  // ...
}

for _, tt := range tests {
  // ...
}
```

#### Избегайте излишней сложности табличных тестов

Табличные тесты могут быть сложными для чтения и сопровождения, если субтесты содержат условные
утверждения или другую логику ветвления. Табличные тесты не следует использовать всякий
раз, когда внутри субтестов должна быть сложная или условная логика (т.е. сложная логика внутри цикла `for`).

Большие и сложные табличные тесты ухудшают читаемость и удобство сопровождения, поскольку у средств чтения тестов могут
возникнуть трудности с отладкой возникающих ошибок.

Подобные табличные тесты следует разделить либо на несколько тестовых таблиц, либо на несколько
отдельных функций "Test...".

Вот некоторые идеалы, к которым следует стремиться::

* Сосредоточьтесь на самой узкой единице поведения
* Сведите к минимуму "глубину тестирования" и избегайте условных утверждений (см. ниже)
* Убедитесь, что все поля таблицы используются во всех тестах
* Убедитесь, что вся логика тестирования выполняется для всех вариантов таблиц

В этом контексте "глубина тестирования" означает "в рамках данного теста количество
последовательных утверждений, для выполнения которых требуются предыдущие утверждения" (аналогично
цикломатической сложности).
Наличие "более мелких" тестов означает, что между
утверждениями меньше взаимосвязей и, что более важно, что эти утверждения с меньшей вероятностью
будут условными по умолчанию.

В частности, табличные тесты могут стать запутанными и трудными для чтения, если они используют несколько
путей ветвления (например, `shouldError`, `expectCall` и т.д.), используют множество инструкций `if` для
конкретных условных ожиданий (например, `shouldCallFoo`) или размещают функции внутри
таблицы (например, `setupMocks func(*FooMock)`).

Однако при тестировании поведения, которое
изменяется только в зависимости от измененных входных данных, может оказаться предпочтительнее сгруппировать похожие случаи
в табличный тест, чтобы лучше проиллюстрировать, как меняется поведение во всех входных данных,
а не разбивать сопоставимые в остальном блоки на отдельные тесты
и усложняет их сравнение и противопоставление.

Если текст теста короткий и понятный,
допустимо иметь единый путь ветвления для случаев успеха и неудачи
с полем таблицы, например "shouldErr", для указания ожидаемых ошибок.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
func TestComplicatedTable(t *testing.T) {
  tests := []struct {
    give          string
    want          string
    wantErr       error
    shouldCallX   bool
    shouldCallY   bool
    giveXResponse string
    giveXErr      error
    giveYResponse string
    giveYErr      error
  }{
    // ...
  }

  for _, tt := range tests {
    t.Run(tt.give, func(t *testing.T) {
      // setup mocks
      ctrl := gomock.NewController(t)
      xMock := xmock.NewMockX(ctrl)
      if tt.shouldCallX {
        xMock.EXPECT().Call().Return(
          tt.giveXResponse, tt.giveXErr,
        )
      }
      yMock := ymock.NewMockY(ctrl)
      if tt.shouldCallY {
        yMock.EXPECT().Call().Return(
          tt.giveYResponse, tt.giveYErr,
        )
      }

      got, err := DoComplexThing(tt.give, xMock, yMock)

      // verify results
      if tt.wantErr != nil {
        require.EqualError(t, err, tt.wantErr)
        return
      }
      require.NoError(t, err)
      assert.Equal(t, want, got)
    })
  }
}
```

</td><td>

```go
func TestShouldCallX(t *testing.T) {
  // setup mocks
  ctrl := gomock.NewController(t)
  xMock := xmock.NewMockX(ctrl)
  xMock.EXPECT().Call().Return("XResponse", nil)

  yMock := ymock.NewMockY(ctrl)

  got, err := DoComplexThing("inputX", xMock, yMock)

  require.NoError(t, err)
  assert.Equal(t, "want", got)
}

func TestShouldCallYAndFail(t *testing.T) {
  // setup mocks
  ctrl := gomock.NewController(t)
  xMock := xmock.NewMockX(ctrl)

  yMock := ymock.NewMockY(ctrl)
  yMock.EXPECT().Call().Return("YResponse", nil)

  _, err := DoComplexThing("inputY", xMock, yMock)
  assert.EqualError(t, err, "Y failed")
}
```
</td></tr>
</tbody></table>

Такая сложность затрудняет изменение, понимание и доказательство
правильности теста.

Хотя строгих рекомендаций не существует,
при выборе между табличными тестами и отдельными тестами
для нескольких входов/выходов в систему всегда следует учитывать удобство чтения и сопровождения.

#### Параллельные тесты

Параллельные тесты, такие как некоторые специализированные циклы (например, те, которые запускают
goroutines или фиксируют ссылки как часть тела цикла),
должны обеспечивать явное назначение переменных цикла в пределах области действия цикла, чтобы
гарантировать, что они содержат ожидаемые значения.

```go
tests := []struct{
  give string
  // ...
}{
  // ...
}

for _, tt := range tests {
  tt := tt // for t.Parallel
  t.Run(tt.give, func(t *testing.T) {
    t.Parallel()
    // ...
  })
}
```

В приведенном выше примере мы должны объявить переменную `tt`
, область действия которой ограничена итерацией цикла, из-за использования `t.t` приведена функция `Parallel()`.
Если мы этого не сделаем, большинство или все тесты получат неожиданное значение для
`tt` или значение, которое меняется по мере их выполнения.

<!-- TODO: Explain how to use _test packages. -->

### Функциональные параметры

Функциональные параметры - это шаблон, в котором вы объявляете непрозрачный тип "Option"
, который записывает информацию в некоторую внутреннюю структуру. Вы принимаете различное количество
этих параметров и действуете на основе полной информации, записанной параметрами во
внутренней структуре.

Используйте этот шаблон для необязательных аргументов в конструкторах и других общедоступных API
, которые, как вы предполагаете, потребуется расширить, особенно если у вас уже есть три или
более аргумента для этих функций.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
// package db

func Open(
  addr string,
  cache bool,
  logger *zap.Logger
) (*Connection, error) {
  // ...
}
```

</td><td>

```go
// package db

type Option interface {
  // ...
}

func WithCache(c bool) Option {
  // ...
}

func WithLogger(log *zap.Logger) Option {
  // ...
}

// Open creates a connection.
func Open(
  addr string,
  opts ...Option,
) (*Connection, error) {
  // ...
}
```

</td></tr>
<tr><td>

Параметры кэша и регистратора должны быть указаны всегда, даже если пользователь
хочет использовать параметры по умолчанию.

```go
db.Open(addr, db.DefaultCache, zap.NewNop())
db.Open(addr, db.DefaultCache, log)
db.Open(addr, false /* cache */, zap.NewNop())
db.Open(addr, false /* cache */, log)
```

</td><td>

Опции предоставляются только в случае необходимости.

```go
db.Open(addr)
db.Open(addr, db.WithLogger(log))
db.Open(addr, db.WithCache(false))
db.Open(
  addr,
  db.WithCache(false),
  db.WithLogger(log),
)
```

</td></tr>
</tbody></table>

Мы предлагаем способ реализации этого шаблона с помощью интерфейса `Option`,
который содержит неэкспортированный метод, записывающий параметры в неэкспортированную структуру `options`.

```go
type options struct {
  cache  bool
  logger *zap.Logger
}

type Option interface {
  apply(*options)
}

type cacheOption bool

func (c cacheOption) apply(opts *options) {
  opts.cache = bool(c)
}

func WithCache(c bool) Option {
  return cacheOption(c)
}

type loggerOption struct {
  Log *zap.Logger
}

func (l loggerOption) apply(opts *options) {
  opts.logger = l.Log
}

func WithLogger(log *zap.Logger) Option {
  return loggerOption{Log: log}
}

// Open creates a connection.
func Open(
  addr string,
  opts ...Option,
) (*Connection, error) {
  options := options{
    cache:  defaultCache,
    logger: zap.NewNop(),
  }

  for _, o := range opts {
    o.apply(&options)
  }

  // ...
}
```

Обратите внимание, что существует способ реализации этого шаблона с помощью замыканий, но мы
считаем, что приведенный выше шаблон обеспечивает большую гибкость для авторов и
проще в отладке и тестировании для пользователей. В частности, это позволяет
сравнивать параметры друг с другом в тестах и макетах, а также при закрытии, когда это
невозможно. Кроме того, это позволяет options реализовывать другие интерфейсы, включая
`fmt.Stringer`, который позволяет создавать понятные пользователю строковые представления
параметров.

Смотрите также,

- [Самореферентные функции и дизайн опций]
- [Функциональные возможности для дружественных API-интерфейсов](https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis)

<!-- TODO: replace this with parameter structs and functional options, when to
use one vs other -->

## Linting

Более важным, чем любой "благословенный" набор линтеров, является последовательная линтинг-обработка всей
кодовой базы.

Мы рекомендуем использовать как минимум следующие линтеры, поскольку считаем, что они
помогают выявлять наиболее распространенные проблемы, а также устанавливают высокие требования к коду
качество без излишних предписаний:

- [errcheck](https://github.com/kisielk/errcheck) для обеспечения обработки ошибок
- [goimports](https://pkg.go.dev/golang.org/x/tools/cmd/goimports) для форматирования кода и управления импортом
- [golint](https://github.com/golang/lint) для выявления распространенных ошибок в стиле
- [govet](https://pkg.go.dev/cmd/vet) для анализа кода на наличие распространенных ошибок
- [staticcheck](https://staticcheck.dev) для выполнения различных проверок статического анализа

### Lint Runners

Мы рекомендуем [golangci-lint](https://github.com/golangci/golangci-lint) в качестве универсального средства компоновки для Go code, в основном из-за
его производительности в больших кодовых базах и возможности настраивать и использовать множество
канонических линтеров одновременно. В этом репозитории есть пример конфигурационного файла [.golangci.yml](https://github.com/uber-go/guide/blob/master/.golangci.yml)
с рекомендуемыми средствами компоновки и настройками.

В golangci-lint есть [различные средства компоновки](https://golangci-lint.run/usage/linters/), доступные для использования. Вышеуказанные средства компоновки являются
рекомендуется в качестве базового набора, и мы рекомендуем командам добавлять любые дополнительные средства компоновки
, которые имеют смысл для их проектов.
