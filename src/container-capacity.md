# Предпочтительнее указывать емкость контейнера

По возможности указывайте емкость контейнера, чтобы заранее выделить память для
контейнера. Это сводит к минимуму последующие выделения (путем копирования и
изменения размера контейнера) по мере добавления элементов.

## Указание емкости карты дает подсказки

Там, где это возможно, указывайте емкость при инициализации
карт с помощью `make()`.

```go
make(map[T1]T2, hint)
```

Предоставляя подсказку о емкости для `make()`, вы пытаетесь настроить правильный размер
карты во время инициализации, что уменьшает необходимость в увеличении
карты и распределении ресурсов по мере добавления элементов на карту.

Обратите внимание, что, в отличие от фрагментов, подсказки о емкости карты не гарантируют полного и
упреждающего распределения, а используются для приблизительного определения количества требуемых сегментов
хэш-карты. Следовательно, при добавлении элементов на карту все равно могут происходить перераспределения
, даже до указанной емкости.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
m := make(map[string]os.FileInfo)

files, _ := os.ReadDir("./files")
for _, f := range files {
    m[f.Name()] = f
}
```

</td><td>

```go

files, _ := os.ReadDir("./files")

m := make(map[string]os.DirEntry, len(files))
for _, f := range files {
    m[f.Name()] = f
}
```

</td></tr>
<tr><td>

`m` создается без указания размера; во время назначения может быть выделено больше
ресурсов.

</td><td>

`m` создается с указанием размера; во время назначения может быть выделено меньше
ресурсов.

</td></tr>
</tbody></table>

## Указание емкости среза

По возможности указывайте емкость при инициализации срезов с помощью "make()",
особенно при добавлении.

```go
make([]T, length, capacity)
```

В отличие от maps, емкость фрагмента не является подсказкой: компилятор выделит достаточно
памяти для емкости фрагмента, как указано в `make()`, что означает, что
последующие операции `append()` не будут требовать выделения нулевого объема (до тех пор, пока длина
фрагмента не будет соответствовать емкости, после чего любое добавление потребуется изменить размер
для размещения дополнительных элементов).

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
for n := 0; n < b.N; n++ {
  data := make([]int, 0)
  for k := 0; k < size; k++{
    data = append(data, k)
  }
}
```

</td><td>

```go
for n := 0; n < b.N; n++ {
  data := make([]int, 0, size)
  for k := 0; k < size; k++{
    data = append(data, k)
  }
}
```

</td></tr>
<tr><td>

```plain
BenchmarkBad-4    100000000    2.48s
```

</td><td>

```plain
BenchmarkGood-4   100000000    0.21s
```

</td></tr>
</tbody></table>
