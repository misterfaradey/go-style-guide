# Перенос ошибок

Существует три основных варианта распространения ошибок в случае сбоя вызова:

- вернуть исходную ошибку как есть
- добавить контекст с помощью `fmt.Errorf` и глагола `%w`
- добавьте контекст с помощью `fmt.Errorf` и глагола `%v`

Верните исходную ошибку как есть, если нет дополнительного контекста для добавления.
При этом сохраняются исходный тип ошибки и сообщение.
Это хорошо подходит для случаев, когда исходное сообщение об ошибке
содержит достаточно информации, чтобы отследить, откуда оно пришло.

В противном случае, по возможности, добавьте контекст к сообщению об ошибке
, чтобы вместо неопределенной ошибки, такой как "отказано в подключении", отображалась ошибка,
вы получаете более полезные ошибки, такие как "вызов службы foo: отказано в подключении".

Используйте `fmt.Errorf`, чтобы добавить контекст к вашим ошибкам,
выбирая между глаголами `%w` или `%v`
в зависимости от того, сможет ли вызывающий
объект сопоставить и извлечь основную причину.

- Используйте `%w`, если вызывающий абонент должен иметь доступ к основной ошибке.
  Это хорошее значение по умолчанию для большинства обернутых ошибок,
  но имейте в виду, что вызывающие абоненты могут начать полагаться на такое поведение.
  Таким образом, в случаях, когда обернутая ошибка является известным значением "var" или типом,
  задокументируйте и протестируйте ее как часть контракта вашей функции.
- Используйте `%v`, чтобы скрыть основную ошибку.
  Вызывающие абоненты не смогут найти ее,
  но вы можете переключиться на "%w" в будущем, если потребуется.

При добавлении контекста к возвращаемым ошибкам сохраняйте краткость контекста, избегая
таких фраз, как "не удалось выполнить", которые указывают на очевидное и накапливаются по мере распространения ошибки
по стеку:

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
s, err := store.New()
if err != nil {
    return fmt.Errorf(
        "failed to create new store: %w", err)
}
```

</td><td>

```go
s, err := store.New()
if err != nil {
    return fmt.Errorf(
        "new store: %w", err)
}
```

</td></tr><tr><td>

```plain
failed to x: failed to y: failed to create new store: the error
```

</td><td>

```plain
x: y: new store: the error
```

</td></tr>
</tbody></table>

Однако, как только ошибка отправляется в другую систему, должно быть ясно
, что сообщение является ошибкой (например, тег "err" или префикс "Failed" в журналах).

Смотрите также [Не просто проверяйте ошибки, а корректно обрабатывайте их].

[Не просто проверяйте ошибки, а корректно обрабатывайте их]: https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully
