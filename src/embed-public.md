# Избегайте встраивания типов в общедоступные структуры

Эти встроенные типы приводят к утечке информации о реализации, препятствуют эволюции типов и
скрывают документацию.

Предполагая, что вы реализовали множество типов списков, используя общий
"AbstractList", избегайте встраивания "AbstractList" в ваши конкретные
реализации списков.
Вместо этого от руки запишите в свой конкретный список только те методы, которые будут делегированы
абстрактному списку.

```go
type AbstractList struct {}

// Add добавляет объект в список.
func (l *AbstractList) Add(e Entity) {
  // ...
}

// Remove удаляет объект из списка.
func (l *AbstractList) Remove(e Entity) {
  // ...
}
```

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
// ConcreteList - это список сущностей.
type ConcreteList struct {
  *AbstractList
}
```

</td><td>

```go
// ConcreteList - это список сущностей.
type ConcreteList struct {
  list *AbstractList
}

// Add добавляет объект в список.
func (l *ConcreteList) Add(e Entity) {
  l.list.Add(e)
}

// Remove удаляет объект из списка.
func (l *ConcreteList) Remove(e Entity) {
  l.list.Remove(e)
}
```

</td></tr>
</tbody></table>

Go допускает [type embedding] в качестве компромисса между наследованием и композицией.
Внешний тип получает неявные копии методов встроенного типа.
Эти методы по умолчанию делегируются тому же методу встроенного
экземпляра.

  [type embedding]: https://go.dev/doc/effective_go#embedding

Структура также получает поле с тем же именем, что и тип.
Таким образом, если встроенный тип является общедоступным, то и поле будет общедоступным.
Для обеспечения обратной совместимости каждая будущая версия внешнего типа должна
сохранять встроенный тип.

Встроенный тип редко бывает необходим.
Это удобство, которое помогает вам избежать написания утомительных методов делегирования.

Даже внедрение совместимого интерфейса AbstractList *interface* вместо struct
предоставило бы разработчику больше гибкости для внесения изменений в будущем, но все равно
привело бы к утечке информации о том, что конкретные списки используют абстрактную реализацию.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
// AbstractList - это обобщенная реализация
// для различных видов списков сущностей.
type AbstractList interface {
  Add(Entity)
  Remove(Entity)
}

// ConcreteList - это список сущностей.
type ConcreteList struct {
  AbstractList
}
```

</td><td>

```go
// ConcreteList is a list of entities.
type ConcreteList struct {
  list AbstractList
}

// Add adds an entity to the list.
func (l *ConcreteList) Add(e Entity) {
  l.list.Add(e)
}

// Remove removes an entity from the list.
func (l *ConcreteList) Remove(e Entity) {
  l.list.Remove(e)
}
```

</td></tr>
</tbody></table>

Как во встроенной структуре, так и во встроенном интерфейсе встроенный тип
накладывает ограничения на эволюцию типа.

- Добавление методов во встроенный интерфейс является кардинальным изменением.
- Удаление методов из встроенной структуры является кардинальным изменением.
- Удаление встроенного типа является кардинальным изменением.
- Замена встроенного типа даже на альтернативный, удовлетворяющий тем же требованиям.
  интерфейс - это кардинальное изменение.

Хотя написание этих методов делегирования является утомительным занятием, дополнительные усилия скрывают
детали реализации, оставляют больше возможностей для изменений, а также
устраняет косвенные ссылки для поиска полного интерфейса списка в
документации.
