# Приемники и интерфейсы

Методы с приемниками значений могут вызываться как для указателей, так и для значений.
Методы с приемниками указателей могут вызываться только для указателей или [адресуемых значений].

[адресуемые значения]: https://go.dev/ref/spec#Method_values

Например,

```go
type S struct {
  data string
}

func (s S) Read() string {
  return s.data
}

func (s *S) Write(str string) {
  s.data = str
}

// Мы не можем получить указатели на значения, хранящиеся в картах, потому что они не являются
// адресуемыми значениями.
sVals := map[int]S{1: {"A"}}

// Мы можем вызвать Read для значений, хранящихся в map, потому что Read
// имеет приемник значений, который не требует, чтобы значение
// было адресуемым.
sVals[1].Read()

// Мы не можем вызвать функцию Write для значений, хранящихся на карте, потому что функция Write
// имеет приемник указателей, а получить указатель
// на значение, хранящееся на карте, невозможно.
//
// sVals[1].Write("test")

sPtrs := map[int]*S{1: {"A"}}

// Вы можете вызывать как Read, так и Write, если карта хранит указатели,
// потому что указатели по своей сути адресуемы.
sPtrs[1].Read()
sPtrs[1].Write("test")
```

Аналогично, интерфейс может быть удовлетворен указателем, даже если у метода есть
получатель значений.

```go
type F interface {
  f()
}

type S1 struct{}

func (s S1) f() {}

type S2 struct{}

func (s *S2) f() {}

s1Val := S1{}
s1Ptr := &S1{}
s2Val := S2{}
s2Ptr := &S2{}

var i F
i = s1Val
i = s1Ptr
i = s2Ptr

// // Следующее не скомпилируется, поскольку s2Val - это значение, а для f нет приемника значений.
// i = s2Val
```

В Effective Go есть хорошая статья о [указатели и  значения].

[Указатели и  Значения]: https://go.dev/doc/effective_go#pointers_vs_values
