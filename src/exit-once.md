# Завершите работу один раз

Если возможно, предпочтите вызывать "os.Exit" или "log.Fatal" **не более одного раза ** в вашем
`main()`. Если существует несколько сценариев возникновения ошибок, которые останавливают выполнение программы,
выделите эту логику в отдельную функцию и возвращайте ошибки из нее.

Это сокращает вашу функцию `main()` и помещает всю ключевую
бизнес-логику в отдельную тестируемую функцию.

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
package main

func main() {
  args := os.Args[1:]
  if len(args) != 1 {
    log.Fatal("missing file")
  }
  name := args[0]

  f, err := os.Open(name)
  if err != nil {
    log.Fatal(err)
  }
  defer f.Close()

	// Если мы вызовем log.Fatal после этой строки,
	// f.Close вызываться не будет.

  b, err := io.ReadAll(f)
  if err != nil {
    log.Fatal(err)
  }

  // ...
}
```

</td><td>

```go
package main

func main() {
  if err := run(); err != nil {
    log.Fatal(err)
  }
}

func run() error {
  args := os.Args[1:]
  if len(args) != 1 {
    return errors.New("missing file")
  }
  name := args[0]

  f, err := os.Open(name)
  if err != nil {
    return err
  }
  defer f.Close()

  b, err := io.ReadAll(f)
  if err != nil {
    return err
  }

  // ...
}
```

</td></tr>
</tbody></table>

В приведенном выше примере используется `log.Fatal`, но это руководство также применимо к
"os.Exit" или любому библиотечному коду, который вызывает "os.Exit`.

```go
func main() {
  if err := run(); err != nil {
    fmt.Fprintln(os.Stderr, err)
    os.Exit(1)
  }
}
```

Вы можете изменить сигнатуру `run()` в соответствии с вашими потребностями.
Например, если ваша программа должна завершать работу с определенными кодами завершения при сбоях,
`run()` может возвращать код завершения вместо ошибки.
Это позволяет модульным тестам также проверять это поведение напрямую.

```go
func main() {
  os.Exit(run(args))
}

func run() (exitCode int) {
  // ...
}
```

В целом, обратите внимание, что функция `run()`, используемая в этих примерах
, не является обязательной.
В названии, подписи и настройках функции `run()` предусмотрена гибкость.
Помимо прочего, вы можете:

- принимать нераспечатанные аргументы командной строки (например, `run(os.Args[1:])`)
- анализировать аргументы командной строки в `main()` и передавать их в `run`
- используйте пользовательский тип ошибки, чтобы перенести код завершения обратно в "main()"
- перенесите бизнес-логику на другой уровень абстракции, отличный от "package main"

Это руководство требует, чтобы в вашем "main()" было только одно место.
ответственный за фактический выход из процесса.
