# Обрабатывать ошибки один раз

Когда вызывающий абонент получает сообщение об ошибке от вызываемого объекта,
он может обрабатывать его различными способами
в зависимости от того, что ему известно об ошибке.

К ним относятся, но не ограничиваются ими:

- если контракт вызываемого абонента определяет конкретные ошибки,
  сопоставьте ошибку с "errors.Is` или `errors.As"
  и обработайте ветви по-разному
- если ошибка исправима,
  зарегистрируйте ошибку и исправьте ее корректно
- если ошибка представляет собой сбой, связанный с конкретным доменом,
  возвращает четко определенную ошибку
- возвращает ошибку, либо [завернутую](error-wrap.md), либо дословно

Независимо от того, как вызывающий абонент обрабатывает ошибку,
обычно он должен обрабатывать каждую ошибку только один раз.
Вызывающий абонент не должен, например, регистрировать ошибку и затем возвращать ее,
поскольку *его* вызывающие абоненты также могут обрабатывать ошибку.

Например, рассмотрим следующие случаи:

<table>
<thead><tr><th>Description</th><th>Code</th></tr></thead>
<tbody>
<tr><td>

**Bad**: Зарегистрируйте ошибку и верните ее

Абоненты, находящиеся выше по стеку, скорее всего, предпримут аналогичные действия с ошибкой.
Это приведет к появлению большого количества помех в журналах приложений, что не принесет никакой пользы.

</td><td>

```go
u, err := getUser(id)
if err != nil {
  // BAD: See description
  log.Printf("Could not get user %q: %v", id, err)
  return err
}
```

</td></tr>
<tr><td>

**Good**: Обработайте ошибку и верните ее обратно

Вызывающие абоненты, расположенные выше по стеку, обработают ошибку.
Использование "%w" гарантирует, что они смогут сопоставить ошибку с `errors.Is` или `errors.As"
, если это уместно.

</td><td>

```go
u, err := getUser(id)
if err != nil {
  return fmt.Errorf("get user %q: %w", id, err)
}
```

</td></tr>
<tr><td>

**Good**: Зарегистрируйте ошибку и исправьте ее должным образом

Если операция не является строго необходимой, 
мы можем обеспечить исправление ошибки,
но без сбоев, восстановив ее.

</td><td>

```go
if err := emitMetrics(); err != nil {
	// Невозможность записи показателей 
	// не должна приводить к прерыванию работы приложения.
  log.Printf("Could not emit metrics: %v", err)
}

```

</td></tr>
<tr><td>

**Good**: Сопоставьте ошибку и корректно устраните ее

Если вызываемый объект определяет конкретную ошибку в своем контракте
и сбой можно устранить,
сопоставьте этот случай ошибки и корректно устраните его.
Во всех остальных случаях завершите обработку ошибки и верните ее.

Вызывающие абоненты, находящиеся выше по стеку, будут обрабатывать другие ошибки.

</td><td>

```go
tz, err := getUserTimeZone(id)
if err != nil {
  if errors.Is(err, ErrUserNotFound) {
    // Пользователь не существует. Используйте UTC.
    tz = time.UTC
  } else {
    return fmt.Errorf("get user %q: %w", id, err)
  }
}
```

</td></tr>
</tbody></table>
