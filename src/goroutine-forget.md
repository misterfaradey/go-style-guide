# Не запускайте и не забывайте о подпрограммах

Подпрограммы просты, но они не бесплатны:
как минимум, они требуют памяти для своего стека и центрального процессора для планирования.
Несмотря на то, что эти затраты невелики при обычном использовании подпрограмм,
они могут вызвать значительные проблемы с производительностью
при запуске в больших количествах без контролируемого времени жизни.
Программы с неуправляемым временем жизни также могут вызывать другие проблемы
, например, предотвращать сборку мусора для неиспользуемых объектов
и сохранять ресурсы, которые в противном случае больше не используются.

Поэтому не допускайте утечки программ в рабочий код.
Используйте [go.uber.org/goleak](https://pkg.go.dev/go.uber.org/goleak)
для проверки на наличие утечек в программах внутри пакетов, которые могут вызывать такие программы.

В общем, каждая программа:

- должна иметь предсказуемое время, когда она перестанет выполняться; или
- должен быть способ подать программе сигнал о том, что она должна остановиться

В обоих случаях должен быть код для блокировки и ожидания
завершения работы программы.

Например:

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
go func() {
  for {
    flush()
    time.Sleep(delay)
  }
}()
```

</td><td>

```go
var (
  stop = make(chan struct{}) // tells the goroutine to stop
  done = make(chan struct{}) // tells us that the goroutine exited
)
go func() {
  defer close(done)

  ticker := time.NewTicker(delay)
  defer ticker.Stop()
  for {
    select {
    case <-ticker.C:
      flush()
    case <-stop:
      return
    }
  }
}()

// Elsewhere...
close(stop)  // signal the goroutine to stop
<-done       // and wait for it to exit
```

</td></tr>
<tr><td>

Остановить эту процедуру невозможно.
Она будет выполняться до завершения работы приложения.

</td><td>

Эту подпрограмму можно остановить с помощью `закрыть (stop)`,
и мы не можем ждать, пока она завершится с помощью `<-done`.

</td></tr>
</tbody></table>
